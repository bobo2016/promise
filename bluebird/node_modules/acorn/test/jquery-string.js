/* Silly noise to be able to load in source code without doing an XMLHttpReq */var jquery164 = "/*!\n\
 * jQuery JavaScript Library v1.6.4\n\
 * http://jquery.com/\n\
 *\n\
 * Copyright 2011, John Resig\n\
 * Dual licensed under the MIT or GPL Version 2 licenses.\n\
 * http://jquery.org/license\n\
 *\n\
 * Includes Sizzle.js\n\
 * http://sizzlejs.com/\n\
 * Copyright 2011, The Dojo Foundation\n\
 * Released under the MIT, BSD, and GPL Licenses.\n\
 *\n\
 * Date: Mon Sep 12 18:54:48 2011 -0400\n\
 */\n\
(function( window, undefined ) {\n\
\n\
// Use the correct document accordingly with window argument (sandbox)\n\
var document = window.document,\n\
	navigator = window.navigator,\n\
	location = window.location;\n\
var jQuery = (function() {\n\
\n\
// Define a local copy of jQuery\n\
var jQuery = function( selector, context ) {\n\
		// The jQuery object is actually just the init constructor 'enhanced'\n\
		return new jQuery.fn.init( selector, context, rootjQuery );\n\
	},\n\
\n\
	// Map over jQuery in case of overwrite\n\
	_jQuery = window.jQuery,\n\
\n\
	// Map over the $ in case of overwrite\n\
	_$ = window.$,\n\
\n\
	// A central reference to the root jQuery(document)\n\
	rootjQuery,\n\
\n\
	// A simple way to check for HTML strings or ID strings\n\
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\
	quickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n\
\n\
	// Check if a string has a non-whitespace character in it\n\
	rnotwhite = /\\S/,\n\
\n\
	// Used for trimming whitespace\n\
	trimLeft = /^\\s+/,\n\
	trimRight = /\\s+$/,\n\
\n\
	// Check for digits\n\
	rdigit = /\\d/,\n\
\n\
	// Match a standalone tag\n\
	rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,\n\
\n\
	// JSON RegExp\n\
	rvalidchars = /^[\\],:{}\\s]*$/,\n\
	rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\n\
	rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\n\
	rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n\
\n\
	// Useragent RegExp\n\
	rwebkit = /(webkit)[ \\/]([\\w.]+)/,\n\
	ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n\
	rmsie = /(msie) ([\\w.]+)/,\n\
	rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n\
\n\
	// Matches dashed string for camelizing\n\
	rdashAlpha = /-([a-z]|[0-9])/ig,\n\
	rmsPrefix = /^-ms-/,\n\
\n\
	// Used by jQuery.camelCase as callback to replace()\n\
	fcamelCase = function( all, letter ) {\n\
		return ( letter + \"\" ).toUpperCase();\n\
	},\n\
\n\
	// Keep a UserAgent string for use with jQuery.browser\n\
	userAgent = navigator.userAgent,\n\
\n\
	// For matching the engine and version of the browser\n\
	browserMatch,\n\
\n\
	// The deferred used on DOM ready\n\
	readyList,\n\
\n\
	// The ready event handler\n\
	DOMContentLoaded,\n\
\n\
	// Save a reference to some core methods\n\
	toString = Object.prototype.toString,\n\
	hasOwn = Object.prototype.hasOwnProperty,\n\
	push = Array.prototype.push,\n\
	slice = Array.prototype.slice,\n\
	trim = String.prototype.trim,\n\
	indexOf = Array.prototype.indexOf,\n\
\n\
	// [[Class]] -> type pairs\n\
	class2type = {};\n\
\n\
jQuery.fn = jQuery.prototype = {\n\
	constructor: jQuery,\n\
	init: function( selector, context, rootjQuery ) {\n\
		var match, elem, ret, doc;\n\
\n\
		// Handle $(\"\"), $(null), or $(undefined)\n\
		if ( !selector ) {\n\
			return this;\n\
		}\n\
\n\
		// Handle $(DOMElement)\n\
		if ( selector.nodeType ) {\n\
			this.context = this[0] = selector;\n\
			this.length = 1;\n\
			return this;\n\
		}\n\
\n\
		// The body element only exists once, optimize finding it\n\
		if ( selector === \"body\" && !context && document.body ) {\n\
			this.context = document;\n\
			this[0] = document.body;\n\
			this.selector = selector;\n\
			this.length = 1;\n\
			return this;\n\
		}\n\
\n\
		// Handle HTML strings\n\
		if ( typeof selector === \"string\" ) {\n\
			// Are we dealing with HTML string or an ID?\n\
			if ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\
				// Assume that strings that start and end with <> are HTML and skip the regex check\n\
				match = [ null, selector, null ];\n\
\n\
			} else {\n\
				match = quickExpr.exec( selector );\n\
			}\n\
\n\
			// Verify a match, and that no context was specified for #id\n\
			if ( match && (match[1] || !context) ) {\n\
\n\
				// HANDLE: $(html) -> $(array)\n\
				if ( match[1] ) {\n\
					context = context instanceof jQuery ? context[0] : context;\n\
					doc = (context ? context.ownerDocument || context : document);\n\
\n\
					// If a single string is passed in and it's a single tag\n\
					// just do a createElement and skip the rest\n\
					ret = rsingleTag.exec( selector );\n\
\n\
					if ( ret ) {\n\
						if ( jQuery.isPlainObject( context ) ) {\n\
							selector = [ document.createElement( ret[1] ) ];\n\
							jQuery.fn.attr.call( selector, context, true );\n\
\n\
						} else {\n\
							selector = [ doc.createElement( ret[1] ) ];\n\
						}\n\
\n\
					} else {\n\
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );\n\
						selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;\n\
					}\n\
\n\
					return jQuery.merge( this, selector );\n\
\n\
				// HANDLE: $(\"#id\")\n\
				} else {\n\
					elem = document.getElementById( match[2] );\n\
\n\
					// Check parentNode to catch when Blackberry 4.6 returns\n\
					// nodes that are no longer in the document #6963\n\
					if ( elem && elem.parentNode ) {\n\
						// Handle the case where IE and Opera return items\n\
						// by name instead of ID\n\
						if ( elem.id !== match[2] ) {\n\
							return rootjQuery.find( selector );\n\
						}\n\
\n\
						// Otherwise, we inject the element directly into the jQuery object\n\
						this.length = 1;\n\
						this[0] = elem;\n\
					}\n\
\n\
					this.context = document;\n\
					this.selector = selector;\n\
					return this;\n\
				}\n\
\n\
			// HANDLE: $(expr, $(...))\n\
			} else if ( !context || context.jquery ) {\n\
				return (context || rootjQuery).find( selector );\n\
\n\
			// HANDLE: $(expr, context)\n\
			// (which is just equivalent to: $(context).find(expr)\n\
			} else {\n\
				return this.constructor( context ).find( selector );\n\
			}\n\
\n\
		// HANDLE: $(function)\n\
		// Shortcut for document ready\n\
		} else if ( jQuery.isFunction( selector ) ) {\n\
			return rootjQuery.ready( selector );\n\
		}\n\
\n\
		if (selector.selector !== undefined) {\n\
			this.selector = selector.selector;\n\
			this.context = selector.context;\n\
		}\n\
\n\
		return jQuery.makeArray( selector, this );\n\
	},\n\
\n\
	// Start with an empty selector\n\
	selector: \"\",\n\
\n\
	// The current version of jQuery being used\n\
	jquery: \"1.6.4\",\n\
\n\
	// The default length of a jQuery object is 0\n\
	length: 0,\n\
\n\
	// The number of elements contained in the matched element set\n\
	size: function() {\n\
		return this.length;\n\
	},\n\
\n\
	toArray: function() {\n\
		return slice.call( this, 0 );\n\
	},\n\
\n\
	// Get the Nth element in the matched element set OR\n\
	// Get the whole matched element set as a clean array\n\
	get: function( num ) {\n\
		return num == null ?\n\
\n\
			// Return a 'clean' array\n\
			this.toArray() :\n\
\n\
			// Return just the object\n\
			( num < 0 ? this[ this.length + num ] : this[ num ] );\n\
	},\n\
\n\
	// Take an array of elements and push it onto the stack\n\
	// (returning the new matched element set)\n\
	pushStack: function( elems, name, selector ) {\n\
		// Build a new jQuery matched element set\n\
		var ret = this.constructor();\n\
\n\
		if ( jQuery.isArray( elems ) ) {\n\
			push.apply( ret, elems );\n\
\n\
		} else {\n\
			jQuery.merge( ret, elems );\n\
		}\n\
\n\
		// Add the old object onto the stack (as a reference)\n\
		ret.prevObject = this;\n\
\n\
		ret.context = this.context;\n\
\n\
		if ( name === \"find\" ) {\n\
			ret.selector = this.selector + (this.selector ? \" \" : \"\") + selector;\n\
		} else if ( name ) {\n\
			ret.selector = this.selector + \".\" + name + \"(\" + selector + \")\";\n\
		}\n\
\n\
		// Return the newly-formed element set\n\
		return ret;\n\
	},\n\
\n\
	// Execute a callback for every element in the matched set.\n\
	// (You can seed the arguments with an array of args, but this is\n\
	// only used internally.)\n\
	each: function( callback, args ) {\n\
		return jQuery.each( this, callback, args );\n\
	},\n\
\n\
	ready: function( fn ) {\n\
		// Attach the listeners\n\
		jQuery.bindReady();\n\
\n\
		// Add the callback\n\
		readyList.done( fn );\n\
\n\
		return this;\n\
	},\n\
\n\
	eq: function( i ) {\n\
		return i === -1 ?\n\
			this.slice( i ) :\n\
			this.slice( i, +i + 1 );\n\
	},\n\
\n\
	first: function() {\n\
		return this.eq( 0 );\n\
	},\n\
\n\
	last: function() {\n\
		return this.eq( -1 );\n\
	},\n\
\n\
	slice: function() {\n\
		return this.pushStack( slice.apply( this, arguments ),\n\
			\"slice\", slice.call(arguments).join(\",\") );\n\
	},\n\
\n\
	map: function( callback ) {\n\
		return this.pushStack( jQuery.map(this, function( elem, i ) {\n\
			return callback.call( elem, i, elem );\n\
		}));\n\
	},\n\
\n\
	end: function() {\n\
		return this.prevObject || this.constructor(null);\n\
	},\n\
\n\
	// For internal use only.\n\
	// Behaves like an Array's method, not like a jQuery method.\n\
	push: push,\n\
	sort: [].sort,\n\
	splice: [].splice\n\
};\n\
\n\
// Give the init function the jQuery prototype for later instantiation\n\
jQuery.fn.init.prototype = jQuery.fn;\n\
\n\
jQuery.extend = jQuery.fn.extend = function() {\n\
	var options, name, src, copy, copyIsArray, clone,\n\
		target = arguments[0] || {},\n\
		i = 1,\n\
		length = arguments.length,\n\
		deep = false;\n\
\n\
	// Handle a deep copy situation\n\
	if ( typeof target === \"boolean\" ) {\n\
		deep = target;\n\
		target = arguments[1] || {};\n\
		// skip the boolean and the target\n\
		i = 2;\n\
	}\n\
\n\
	// Handle case when target is a string or something (possible in deep copy)\n\
	if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\
		target = {};\n\
	}\n\
\n\
	// extend jQuery itself if only one argument is passed\n\
	if ( length === i ) {\n\
		target = this;\n\
		--i;\n\
	}\n\
\n\
	for ( ; i < length; i++ ) {\n\
		// Only deal with non-null/undefined values\n\
		if ( (options = arguments[ i ]) != null ) {\n\
			// Extend the base object\n\
			for ( name in options ) {\n\
				src = target[ name ];\n\
				copy = options[ name ];\n\
\n\
				// Prevent never-ending loop\n\
				if ( target === copy ) {\n\
					continue;\n\
				}\n\
\n\
				// Recurse if we're merging plain objects or arrays\n\
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\
					if ( copyIsArray ) {\n\
						copyIsArray = false;\n\
						clone = src && jQuery.isArray(src) ? src : [];\n\
\n\
					} else {\n\
						clone = src && jQuery.isPlainObject(src) ? src : {};\n\
					}\n\
\n\
					// Never move original objects, clone them\n\
					target[ name ] = jQuery.extend( deep, clone, copy );\n\
\n\
				// Don't bring in undefined values\n\
				} else if ( copy !== undefined ) {\n\
					target[ name ] = copy;\n\
				}\n\
			}\n\
		}\n\
	}\n\
\n\
	// Return the modified object\n\
	return target;\n\
};\n\
\n\
jQuery.extend({\n\
	noConflict: function( deep ) {\n\
		if ( window.$ === jQuery ) {\n\
			window.$ = _$;\n\
		}\n\
\n\
		if ( deep && window.jQuery === jQuery ) {\n\
			window.jQuery = _jQuery;\n\
		}\n\
\n\
		return jQuery;\n\
	},\n\
\n\
	// Is the DOM ready to be used? Set to true once it occurs.\n\
	isReady: false,\n\
\n\
	// A counter to track how many items to wait for before\n\
	// the ready event fires. See #6781\n\
	readyWait: 1,\n\
\n\
	// Hold (or release) the ready event\n\
	holdReady: function( hold ) {\n\
		if ( hold ) {\n\
			jQuery.readyWait++;\n\
		} else {\n\
			jQuery.ready( true );\n\
		}\n\
	},\n\
\n\
	// Handle when the DOM is ready\n\
	ready: function( wait ) {\n\
		// Either a released hold or an DOMready/load event and not yet ready\n\
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {\n\
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\
			if ( !document.body ) {\n\
				return setTimeout( jQuery.ready, 1 );\n\
			}\n\
\n\
			// Remember that the DOM is ready\n\
			jQuery.isReady = true;\n\
\n\
			// If a normal DOM Ready event fired, decrement, and wait if need be\n\
			if ( wait !== true && --jQuery.readyWait > 0 ) {\n\
				return;\n\
			}\n\
\n\
			// If there are functions bound, to execute\n\
			readyList.resolveWith( document, [ jQuery ] );\n\
\n\
			// Trigger any bound ready events\n\
			if ( jQuery.fn.trigger ) {\n\
				jQuery( document ).trigger( \"ready\" ).unbind( \"ready\" );\n\
			}\n\
		}\n\
	},\n\
\n\
	bindReady: function() {\n\
		if ( readyList ) {\n\
			return;\n\
		}\n\
\n\
		readyList = jQuery._Deferred();\n\
\n\
		// Catch cases where $(document).ready() is called after the\n\
		// browser event has already occurred.\n\
		if ( document.readyState === \"complete\" ) {\n\
			// Handle it asynchronously to allow scripts the opportunity to delay ready\n\
			return setTimeout( jQuery.ready, 1 );\n\
		}\n\
\n\
		// Mozilla, Opera and webkit nightlies currently support this event\n\
		if ( document.addEventListener ) {\n\
			// Use the handy event callback\n\
			document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\
\n\
			// A fallback to window.onload, that will always work\n\
			window.addEventListener( \"load\", jQuery.ready, false );\n\
\n\
		// If IE event model is used\n\
		} else if ( document.attachEvent ) {\n\
			// ensure firing before onload,\n\
			// maybe late but safe also for iframes\n\
			document.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\
\n\
			// A fallback to window.onload, that will always work\n\
			window.attachEvent( \"onload\", jQuery.ready );\n\
\n\
			// If IE and not a frame\n\
			// continually check to see if the document is ready\n\
			var toplevel = false;\n\
\n\
			try {\n\
				toplevel = window.frameElement == null;\n\
			} catch(e) {}\n\
\n\
			if ( document.documentElement.doScroll && toplevel ) {\n\
				doScrollCheck();\n\
			}\n\
		}\n\
	},\n\
\n\
	// See test/unit/core.js for details concerning isFunction.\n\
	// Since version 1.3, DOM methods and functions like alert\n\
	// aren't supported. They return false on IE (#2968).\n\
	isFunction: function( obj ) {\n\
		return jQuery.type(obj) === \"function\";\n\
	},\n\
\n\
	isArray: Array.isArray || function( obj ) {\n\
		return jQuery.type(obj) === \"array\";\n\
	},\n\
\n\
	// A crude way of determining if an object is a window\n\
	isWindow: function( obj ) {\n\
		return obj && typeof obj === \"object\" && \"setInterval\" in obj;\n\
	},\n\
\n\
	isNaN: function( obj ) {\n\
		return obj == null || !rdigit.test( obj ) || isNaN( obj );\n\
	},\n\
\n\
	type: function( obj ) {\n\
		return obj == null ?\n\
			String( obj ) :\n\
			class2type[ toString.call(obj) ] || \"object\";\n\
	},\n\
\n\
	isPlainObject: function( obj ) {\n\
		// Must be an Object.\n\
		// Because of IE, we also have to check the presence of the constructor property.\n\
		// Make sure that DOM nodes and window objects don't pass through, as well\n\
		if ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\
			return false;\n\
		}\n\
\n\
		try {\n\
			// Not own constructor property must be Object\n\
			if ( obj.constructor &&\n\
				!hasOwn.call(obj, \"constructor\") &&\n\
				!hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\
				return false;\n\
			}\n\
		} catch ( e ) {\n\
			// IE8,9 Will throw exceptions on certain host objects #9897\n\
			return false;\n\
		}\n\
\n\
		// Own properties are enumerated firstly, so to speed up,\n\
		// if last one is own, then all properties are own.\n\
\n\
		var key;\n\
		for ( key in obj ) {}\n\
\n\
		return key === undefined || hasOwn.call( obj, key );\n\
	},\n\
\n\
	isEmptyObject: function( obj ) {\n\
		for ( var name in obj ) {\n\
			return false;\n\
		}\n\
		return true;\n\
	},\n\
\n\
	error: function( msg ) {\n\
		throw msg;\n\
	},\n\
\n\
	parseJSON: function( data ) {\n\
		if ( typeof data !== \"string\" || !data ) {\n\
			return null;\n\
		}\n\
\n\
		// Make sure leading/trailing whitespace is removed (IE can't handle it)\n\
		data = jQuery.trim( data );\n\
\n\
		// Attempt to parse using the native JSON parser first\n\
		if ( window.JSON && window.JSON.parse ) {\n\
			return window.JSON.parse( data );\n\
		}\n\
\n\
		// Make sure the incoming data is actual JSON\n\
		// Logic borrowed from http://json.org/json2.js\n\
		if ( rvalidchars.test( data.replace( rvalidescape, \"@\" )\n\
			.replace( rvalidtokens, \"]\" )\n\
			.replace( rvalidbraces, \"\")) ) {\n\
\n\
			return (new Function( \"return \" + data ))();\n\
\n\
		}\n\
		jQuery.error( \"Invalid JSON: \" + data );\n\
	},\n\
\n\
	// Cross-browser xml parsing\n\
	parseXML: function( data ) {\n\
		var xml, tmp;\n\
		try {\n\
			if ( window.DOMParser ) { // Standard\n\
				tmp = new DOMParser();\n\
				xml = tmp.parseFromString( data , \"text/xml\" );\n\
			} else { // IE\n\
				xml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\
				xml.async = \"false\";\n\
				xml.loadXML( data );\n\
			}\n\
		} catch( e ) {\n\
			xml = undefined;\n\
		}\n\
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\
			jQuery.error( \"Invalid XML: \" + data );\n\
		}\n\
		return xml;\n\
	},\n\
\n\
	noop: function() {},\n\
\n\
	// Evaluates a script in a global context\n\
	// Workarounds based on findings by Jim Driscoll\n\
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\
	globalEval: function( data ) {\n\
		if ( data && rnotwhite.test( data ) ) {\n\
			// We use execScript on Internet Explorer\n\
			// We use an anonymous function so that context is window\n\
			// rather than jQuery in Firefox\n\
			( window.execScript || function( data ) {\n\
				window[ \"eval\" ].call( window, data );\n\
			} )( data );\n\
		}\n\
	},\n\
\n\
	// Convert dashed to camelCase; used by the css and data modules\n\
	// Microsoft forgot to hump their vendor prefix (#9572)\n\
	camelCase: function( string ) {\n\
		return string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\
	},\n\
\n\
	nodeName: function( elem, name ) {\n\
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();\n\
	},\n\
\n\
	// args is for internal usage only\n\
	each: function( object, callback, args ) {\n\
		var name, i = 0,\n\
			length = object.length,\n\
			isObj = length === undefined || jQuery.isFunction( object );\n\
\n\
		if ( args ) {\n\
			if ( isObj ) {\n\
				for ( name in object ) {\n\
					if ( callback.apply( object[ name ], args ) === false ) {\n\
						break;\n\
					}\n\
				}\n\
			} else {\n\
				for ( ; i < length; ) {\n\
					if ( callback.apply( object[ i++ ], args ) === false ) {\n\
						break;\n\
					}\n\
				}\n\
			}\n\
\n\
		// A special, fast, case for the most common use of each\n\
		} else {\n\
			if ( isObj ) {\n\
				for ( name in object ) {\n\
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {\n\
						break;\n\
					}\n\
				}\n\
			} else {\n\
				for ( ; i < length; ) {\n\
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {\n\
						break;\n\
					}\n\
				}\n\
			}\n\
		}\n\
\n\
		return object;\n\
	},\n\
\n\
	// Use native String.trim function wherever possible\n\
	trim: trim ?\n\
		function( text ) {\n\
			return text == null ?\n\
				\"\" :\n\
				trim.call( text );\n\
		} :\n\
\n\
		// Otherwise use our own trimming functionality\n\
		function( text ) {\n\
			return text == null ?\n\
				\"\" :\n\
				text.toString().replace( trimLeft, \"\" ).replace( trimRight, \"\" );\n\
		},\n\
\n\
	// results is for internal usage only\n\
	makeArray: function( array, results ) {\n\
		var ret = results || [];\n\
\n\
		if ( array != null ) {\n\
			// The window, strings (and functions) also have 'length'\n\
			// The extra typeof function check is to prevent crashes\n\
			// in Safari 2 (See: #3039)\n\
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n\
			var type = jQuery.type( array );\n\
\n\
			if ( array.length == null || type === \"string\" || type === \"function\" || type === \"regexp\" || jQuery.isWindow( array ) ) {\n\
				push.call( ret, array );\n\
			} else {\n\
				jQuery.merge( ret, array );\n\
			}\n\
		}\n\
\n\
		return ret;\n\
	},\n\
\n\
	inArray: function( elem, array ) {\n\
		if ( !array ) {\n\
			return -1;\n\
		}\n\
\n\
		if ( indexOf ) {\n\
			return indexOf.call( array, elem );\n\
		}\n\
\n\
		for ( var i = 0, length = array.length; i < length; i++ ) {\n\
			if ( array[ i ] === elem ) {\n\
				return i;\n\
			}\n\
		}\n\
\n\
		return -1;\n\
	},\n\
\n\
	merge: function( first, second ) {\n\
		var i = first.length,\n\
			j = 0;\n\
\n\
		if ( typeof second.length === \"number\" ) {\n\
			for ( var l = second.length; j < l; j++ ) {\n\
				first[ i++ ] = second[ j ];\n\
			}\n\
\n\
		} else {\n\
			while ( second[j] !== undefined ) {\n\
				first[ i++ ] = second[ j++ ];\n\
			}\n\
		}\n\
\n\
		first.length = i;\n\
\n\
		return first;\n\
	},\n\
\n\
	grep: function( elems, callback, inv ) {\n\
		var ret = [], retVal;\n\
		inv = !!inv;\n\
\n\
		// Go through the array, only saving the items\n\
		// that pass the validator function\n\
		for ( var i = 0, length = elems.length; i < length; i++ ) {\n\
			retVal = !!callback( elems[ i ], i );\n\
			if ( inv !== retVal ) {\n\
				ret.push( elems[ i ] );\n\
			}\n\
		}\n\
\n\
		return ret;\n\
	},\n\
\n\
	// arg is for internal usage only\n\
	map: function( elems, callback, arg ) {\n\
		var value, key, ret = [],\n\
			i = 0,\n\
			length = elems.length,\n\
			// jquery objects are treated as arrays\n\
			isArray = elems instanceof jQuery || length !== undefined && typeof length === \"number\" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;\n\
\n\
		// Go through the array, translating each of the items to their\n\
		if ( isArray ) {\n\
			for ( ; i < length; i++ ) {\n\
				value = callback( elems[ i ], i, arg );\n\
\n\
				if ( value != null ) {\n\
					ret[ ret.length ] = value;\n\
				}\n\
			}\n\
\n\
		// Go through every key on the object,\n\
		} else {\n\
			for ( key in elems ) {\n\
				value = callback( elems[ key ], key, arg );\n\
\n\
				if ( value != null ) {\n\
					ret[ ret.length ] = value;\n\
				}\n\
			}\n\
		}\n\
\n\
		// Flatten any nested arrays\n\
		return ret.concat.apply( [], ret );\n\
	},\n\
\n\
	// A global GUID counter for objects\n\
	guid: 1,\n\
\n\
	// Bind a function to a context, optionally partially applying any\n\
	// arguments.\n\
	proxy: function( fn, context ) {\n\
		if ( typeof context === \"string\" ) {\n\
			var tmp = fn[ context ];\n\
			context = fn;\n\
			fn = tmp;\n\
		}\n\
\n\
		// Quick check to determine if target is callable, in the spec\n\
		// this throws a TypeError, but we will just return undefined.\n\
		if ( !jQuery.isFunction( fn ) ) {\n\
			return undefined;\n\
		}\n\
\n\
		// Simulated bind\n\
		var args = slice.call( arguments, 2 ),\n\
			proxy = function() {\n\
				return fn.apply( context, args.concat( slice.call( arguments ) ) );\n\
			};\n\
\n\
		// Set the guid of unique handler to the same of original handler, so it can be removed\n\
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;\n\
\n\
		return proxy;\n\
	},\n\
\n\
	// Mutifunctional method to get and set values to a collection\n\
	// The value/s can optionally be executed if it's a function\n\
	access: function( elems, key, value, exec, fn, pass ) {\n\
		var length = elems.length;\n\
\n\
		// Setting many attributes\n\
		if ( typeof key === \"object\" ) {\n\
			for ( var k in key ) {\n\
				jQuery.access( elems, k, key[k], exec, fn, value );\n\
			}\n\
			return elems;\n\
		}\n\
\n\
		// Setting one attribute\n\
		if ( value !== undefined ) {\n\
			// Optionally, function values get executed if exec is true\n\
			exec = !pass && exec && jQuery.isFunction(value);\n\
\n\
			for ( var i = 0; i < length; i++ ) {\n\
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );\n\
			}\n\
\n\
			return elems;\n\
		}\n\
\n\
		// Getting an attribute\n\
		return length ? fn( elems[0], key ) : undefined;\n\
	},\n\
\n\
	now: function() {\n\
		return (new Date()).getTime();\n\
	},\n\
\n\
	// Use of jQuery.browser is frowned upon.\n\
	// More details: http://docs.jquery.com/Utilities/jQuery.browser\n\
	uaMatch: function( ua ) {\n\
		ua = ua.toLowerCase();\n\
\n\
		var match = rwebkit.exec( ua ) ||\n\
			ropera.exec( ua ) ||\n\
			rmsie.exec( ua ) ||\n\
			ua.indexOf(\"compatible\") < 0 && rmozilla.exec( ua ) ||\n\
			[];\n\
\n\
		return { browser: match[1] || \"\", version: match[2] || \"0\" };\n\
	},\n\
\n\
	sub: function() {\n\
		function jQuerySub( selector, context ) {\n\
			return new jQuerySub.fn.init( selector, context );\n\
		}\n\
		jQuery.extend( true, jQuerySub, this );\n\
		jQuerySub.superclass = this;\n\
		jQuerySub.fn = jQuerySub.prototype = this();\n\
		jQuerySub.fn.constructor = jQuerySub;\n\
		jQuerySub.sub = this.sub;\n\
		jQuerySub.fn.init = function init( selector, context ) {\n\
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {\n\
				context = jQuerySub( context );\n\
			}\n\
\n\
			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );\n\
		};\n\
		jQuerySub.fn.init.prototype = jQuerySub.fn;\n\
		var rootjQuerySub = jQuerySub(document);\n\
		return jQuerySub;\n\
	},\n\
\n\
	browser: {}\n\
});\n\
\n\
// Populate the class2type map\n\
jQuery.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function(i, name) {\n\
	class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\
});\n\
\n\
browserMatch = jQuery.uaMatch( userAgent );\n\
if ( browserMatch.browser ) {\n\
	jQuery.browser[ browserMatch.browser ] = true;\n\
	jQuery.browser.version = browserMatch.version;\n\
}\n\
\n\
// Deprecated, use jQuery.browser.webkit instead\n\
if ( jQuery.browser.webkit ) {\n\
	jQuery.browser.safari = true;\n\
}\n\
\n\
// IE doesn't match non-breaking spaces with \\s\n\
if ( rnotwhite.test( \"\\xA0\" ) ) {\n\
	trimLeft = /^[\\s\\xA0]+/;\n\
	trimRight = /[\\s\\xA0]+$/;\n\
}\n\
\n\
// All jQuery objects should point back to these\n\
rootjQuery = jQuery(document);\n\
\n\
// Cleanup functions for the document ready method\n\
if ( document.addEventListener ) {\n\
	DOMContentLoaded = function() {\n\
		document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\
		jQuery.ready();\n\
	};\n\
\n\
} else if ( document.attachEvent ) {\n\
	DOMContentLoaded = function() {\n\
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\
		if ( document.readyState === \"complete\" ) {\n\
			document.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n\
			jQuery.ready();\n\
		}\n\
	};\n\
}\n\
\n\
// The DOM ready check for Internet Explorer\n\
function doScrollCheck() {\n\
	if ( jQuery.isReady ) {\n\
		return;\n\
	}\n\
\n\
	try {\n\
		// If IE is used, use the trick by Diego Perini\n\
		// http://javascript.nwbox.com/IEContentLoaded/\n\
		document.documentElement.doScroll(\"left\");\n\
	} catch(e) {\n\
		setTimeout( doScrollCheck, 1 );\n\
		return;\n\
	}\n\
\n\
	// and execute any waiting functions\n\
	jQuery.ready();\n\
}\n\
\n\
return jQuery;\n\
\n\
})();\n\
\n\
\n\
var // Promise methods\n\
	promiseMethods = \"done fail isResolved isRejected promise then always pipe\".split( \" \" ),\n\
	// Static reference to slice\n\
	sliceDeferred = [].slice;\n\
\n\
jQuery.extend({\n\
	// Create a simple deferred (one callbacks list)\n\
	_Deferred: function() {\n\
		var // callbacks list\n\
			callbacks = [],\n\
			// stored [ context , args ]\n\
			fired,\n\
			// to avoid firing when already doing so\n\
			firing,\n\
			// flag to know if the deferred has been cancelled\n\
			cancelled,\n\
			// the deferred itself\n\
			deferred  = {\n\
\n\
				// done( f1, f2, ...)\n\
				done: function() {\n\
					if ( !cancelled ) {\n\
						var args = arguments,\n\
							i,\n\
							length,\n\
							elem,\n\
							type,\n\
							_fired;\n\
						if ( fired ) {\n\
							_fired = fired;\n\
							fired = 0;\n\
						}\n\
						for ( i = 0, length = args.length; i < length; i++ ) {\n\
							elem = args[ i ];\n\
							type = jQuery.type( elem );\n\
							if ( type === \"array\" ) {\n\
								deferred.done.apply( deferred, elem );\n\
							} else if ( type === \"function\" ) {\n\
								callbacks.push( elem );\n\
							}\n\
						}\n\
						if ( _fired ) {\n\
							deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );\n\
						}\n\
					}\n\
					return this;\n\
				},\n\
\n\
				// resolve with given context and args\n\
				resolveWith: function( context, args ) {\n\
					if ( !cancelled && !fired && !firing ) {\n\
						// make sure args are available (#8421)\n\
						args = args || [];\n\
						firing = 1;\n\
						try {\n\
							while( callbacks[ 0 ] ) {\n\
								callbacks.shift().apply( context, args );\n\
							}\n\
						}\n\
						finally {\n\
							fired = [ context, args ];\n\
							firing = 0;\n\
						}\n\
					}\n\
					return this;\n\
				},\n\
\n\
				// resolve with this as context and given arguments\n\
				resolve: function() {\n\
					deferred.resolveWith( this, arguments );\n\
					return this;\n\
				},\n\
\n\
				// Has this deferred been resolved?\n\
				isResolved: function() {\n\
					return !!( firing || fired );\n\
				},\n\
\n\
				// Cancel\n\
				cancel: function() {\n\
					cancelled = 1;\n\
					callbacks = [];\n\
					return this;\n\
				}\n\
			};\n\
\n\
		return deferred;\n\
	},\n\
\n\
	// Full fledged deferred (two callbacks list)\n\
	Deferred: function( func ) {\n\
		var deferred = jQuery._Deferred(),\n\
			failDeferred = jQuery._Deferred(),\n\
			promise;\n\
		// Add errorDeferred methods, then and promise\n\
		jQuery.extend( deferred, {\n\
			then: function( doneCallbacks, failCallbacks ) {\n\
				deferred.done( doneCallbacks ).fail( failCallbacks );\n\
				return this;\n\
			},\n\
			always: function() {\n\
				return deferred.done.apply( deferred, arguments ).fail.apply( this, arguments );\n\
			},\n\
			fail: failDeferred.done,\n\
			rejectWith: failDeferred.resolveWith,\n\
			reject: failDeferred.resolve,\n\
			isRejected: failDeferred.isResolved,\n\
			pipe: function( fnDone, fnFail ) {\n\
				return jQuery.Deferred(function( newDefer ) {\n\
					jQuery.each( {\n\
						done: [ fnDone, \"resolve\" ],\n\
						fail: [ fnFail, \"reject\" ]\n\
					}, function( handler, data ) {\n\
						var fn = data[ 0 ],\n\
							action = data[ 1 ],\n\
							returned;\n\
						if ( jQuery.isFunction( fn ) ) {\n\
							deferred[ handler ](function() {\n\
								returned = fn.apply( this, arguments );\n\
								if ( returned && jQuery.isFunction( returned.promise ) ) {\n\
									returned.promise().then( newDefer.resolve, newDefer.reject );\n\
								} else {\n\
									newDefer[ action + \"With\" ]( this === deferred ? newDefer : this, [ returned ] );\n\
								}\n\
							});\n\
						} else {\n\
							deferred[ handler ]( newDefer[ action ] );\n\
						}\n\
					});\n\
				}).promise();\n\
			},\n\
			// Get a promise for this deferred\n\
			// If obj is provided, the promise aspect is added to the object\n\
			promise: function( obj ) {\n\
				if ( obj == null ) {\n\
					if ( promise ) {\n\
						return promise;\n\
					}\n\
					promise = obj = {};\n\
				}\n\
				var i = promiseMethods.length;\n\
				while( i-- ) {\n\
					obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];\n\
				}\n\
				return obj;\n\
			}\n\
		});\n\
		// Make sure only one callback list will be used\n\
		deferred.done( failDeferred.cancel ).fail( deferred.cancel );\n\
		// Unexpose cancel\n\
		delete deferred.cancel;\n\
		// Call given func if any\n\
		if ( func ) {\n\
			func.call( deferred, deferred );\n\
		}\n\
		return deferred;\n\
	},\n\
\n\
	// Deferred helper\n\
	when: function( firstParam ) {\n\
		var args = arguments,\n\
			i = 0,\n\
			length = args.length,\n\
			count = length,\n\
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?\n\
				firstParam :\n\
				jQuery.Deferred();\n\
		function resolveFunc( i ) {\n\
			return function( value ) {\n\
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;\n\
				if ( !( --count ) ) {\n\
					// Strange bug in FF4:\n\
					// Values changed onto the arguments object sometimes end up as undefined values\n\
					// outside the $.when method. Cloning the object into a fresh array solves the issue\n\
					deferred.resolveWith( deferred, sliceDeferred.call( args, 0 ) );\n\
				}\n\
			};\n\
		}\n\
		if ( length > 1 ) {\n\
			for( ; i < length; i++ ) {\n\
				if ( args[ i ] && jQuery.isFunction( args[ i ].promise ) ) {\n\
					args[ i ].promise().then( resolveFunc(i), deferred.reject );\n\
				} else {\n\
					--count;\n\
				}\n\
			}\n\
			if ( !count ) {\n\
				deferred.resolveWith( deferred, args );\n\
			}\n\
		} else if ( deferred !== firstParam ) {\n\
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );\n\
		}\n\
		return deferred.promise();\n\
	}\n\
});\n\
\n\
\n\
\n\
jQuery.support = (function() {\n\
\n\
	var div = document.createElement( \"div\" ),\n\
		documentElement = document.documentElement,\n\
		all,\n\
		a,\n\
		select,\n\
		opt,\n\
		input,\n\
		marginDiv,\n\
		support,\n\
		fragment,\n\
		body,\n\
		testElementParent,\n\
		testElement,\n\
		testElementStyle,\n\
		tds,\n\
		events,\n\
		eventName,\n\
		i,\n\
		isSupported;\n\
\n\
	// Preliminary tests\n\
	div.setAttribute(\"className\", \"t\");\n\
	div.innerHTML = \"   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>\";\n\
\n\
\n\
	all = div.getElementsByTagName( \"*\" );\n\
	a = div.getElementsByTagName( \"a\" )[ 0 ];\n\
\n\
	// Can't get basic test support\n\
	if ( !all || !all.length || !a ) {\n\
		return {};\n\
	}\n\
\n\
	// First batch of supports tests\n\
	select = document.createElement( \"select\" );\n\
	opt = select.appendChild( document.createElement(\"option\") );\n\
	input = div.getElementsByTagName( \"input\" )[ 0 ];\n\
\n\
	support = {\n\
		// IE strips leading whitespace when .innerHTML is used\n\
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),\n\
\n\
		// Make sure that tbody elements aren't automatically inserted\n\
		// IE will insert them into empty tables\n\
		tbody: !div.getElementsByTagName( \"tbody\" ).length,\n\
\n\
		// Make sure that link elements get serialized correctly by innerHTML\n\
		// This requires a wrapper element in IE\n\
		htmlSerialize: !!div.getElementsByTagName( \"link\" ).length,\n\
\n\
		// Get the style information from getAttribute\n\
		// (IE uses .cssText instead)\n\
		style: /top/.test( a.getAttribute(\"style\") ),\n\
\n\
		// Make sure that URLs aren't manipulated\n\
		// (IE normalizes it by default)\n\
		hrefNormalized: ( a.getAttribute( \"href\" ) === \"/a\" ),\n\
\n\
		// Make sure that element opacity exists\n\
		// (IE uses filter instead)\n\
		// Use a regex to work around a WebKit issue. See #5145\n\
		opacity: /^0.55$/.test( a.style.opacity ),\n\
\n\
		// Verify style float existence\n\
		// (IE uses styleFloat instead of cssFloat)\n\
		cssFloat: !!a.style.cssFloat,\n\
\n\
		// Make sure that if no value is specified for a checkbox\n\
		// that it defaults to \"on\".\n\
		// (WebKit defaults to \"\" instead)\n\
		checkOn: ( input.value === \"on\" ),\n\
\n\
		// Make sure that a selected-by-default option has a working selected property.\n\
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\
		optSelected: opt.selected,\n\
\n\
		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\
		getSetAttribute: div.className !== \"t\",\n\
\n\
		// Will be defined later\n\
		submitBubbles: true,\n\
		changeBubbles: true,\n\
		focusinBubbles: false,\n\
		deleteExpando: true,\n\
		noCloneEvent: true,\n\
		inlineBlockNeedsLayout: false,\n\
		shrinkWrapBlocks: false,\n\
		reliableMarginRight: true\n\
	};\n\
\n\
	// Make sure checked status is properly cloned\n\
	input.checked = true;\n\
	support.noCloneChecked = input.cloneNode( true ).checked;\n\
\n\
	// Make sure that the options inside disabled selects aren't marked as disabled\n\
	// (WebKit marks them as disabled)\n\
	select.disabled = true;\n\
	support.optDisabled = !opt.disabled;\n\
\n\
	// Test to see if it's possible to delete an expando from an element\n\
	// Fails in Internet Explorer\n\
	try {\n\
		delete div.test;\n\
	} catch( e ) {\n\
		support.deleteExpando = false;\n\
	}\n\
\n\
	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {\n\
		div.attachEvent( \"onclick\", function() {\n\
			// Cloning a node shouldn't copy over any\n\
			// bound event handlers (IE does this)\n\
			support.noCloneEvent = false;\n\
		});\n\
		div.cloneNode( true ).fireEvent( \"onclick\" );\n\
	}\n\
\n\
	// Check if a radio maintains it's value\n\
	// after being appended to the DOM\n\
	input = document.createElement(\"input\");\n\
	input.value = \"t\";\n\
	input.setAttribute(\"type\", \"radio\");\n\
	support.radioValue = input.value === \"t\";\n\
\n\
	input.setAttribute(\"checked\", \"checked\");\n\
	div.appendChild( input );\n\
	fragment = document.createDocumentFragment();\n\
	fragment.appendChild( div.firstChild );\n\
\n\
	// WebKit doesn't clone checked state correctly in fragments\n\
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\
\n\
	div.innerHTML = \"\";\n\
\n\
	// Figure out if the W3C box model works as expected\n\
	div.style.width = div.style.paddingLeft = \"1px\";\n\
\n\
	body = document.getElementsByTagName( \"body\" )[ 0 ];\n\
	// We use our own, invisible, body unless the body is already present\n\
	// in which case we use a div (#9239)\n\
	testElement = document.createElement( body ? \"div\" : \"body\" );\n\
	testElementStyle = {\n\
		visibility: \"hidden\",\n\
		width: 0,\n\
		height: 0,\n\
		border: 0,\n\
		margin: 0,\n\
		background: \"none\"\n\
	};\n\
	if ( body ) {\n\
		jQuery.extend( testElementStyle, {\n\
			position: \"absolute\",\n\
			left: \"-1000px\",\n\
			top: \"-1000px\"\n\
		});\n\
	}\n\
	for ( i in testElementStyle ) {\n\
		testElement.style[ i ] = testElementStyle[ i ];\n\
	}\n\
	testElement.appendChild( div );\n\
	testElementParent = body || documentElement;\n\
	testElementParent.insertBefore( testElement, testElementParent.firstChild );\n\
\n\
	// Check if a disconnected checkbox will retain its checked\n\
	// value of true after appended to the DOM (IE6/7)\n\
	support.appendChecked = input.checked;\n\
\n\
	support.boxModel = div.offsetWidth === 2;\n\
\n\
	if ( \"zoom\" in div.style ) {\n\
		// Check if natively block-level elements act like inline-block\n\
		// elements when setting their display to 'inline' and giving\n\
		// them layout\n\
		// (IE < 8 does this)\n\
		div.style.display = \"inline\";\n\
		div.style.zoom = 1;\n\
		support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );\n\
\n\
		// Check if elements with layout shrink-wrap their children\n\
		// (IE 6 does this)\n\
		div.style.display = \"\";\n\
		div.innerHTML = \"<div style='width:4px;'></div>\";\n\
		support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );\n\
	}\n\
\n\
	div.innerHTML = \"<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>\";\n\
	tds = div.getElementsByTagName( \"td\" );\n\
\n\
	// Check if table cells still have offsetWidth/Height when they are set\n\
	// to display:none and there are still other visible table cells in a\n\
	// table row; if so, offsetWidth/Height are not reliable for use when\n\
	// determining if an element has been hidden directly using\n\
	// display:none (it is still safe to use offsets if a parent element is\n\
	// hidden; don safety goggles and see bug #4512 for more information).\n\
	// (only IE 8 fails this test)\n\
	isSupported = ( tds[ 0 ].offsetHeight === 0 );\n\
\n\
	tds[ 0 ].style.display = \"\";\n\
	tds[ 1 ].style.display = \"none\";\n\
\n\
	// Check if empty table cells still have offsetWidth/Height\n\
	// (IE < 8 fail this test)\n\
	support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );\n\
	div.innerHTML = \"\";\n\
\n\
	// Check if div with explicit width and no margin-right incorrectly\n\
	// gets computed margin-right based on width of container. For more\n\
	// info see bug #3333\n\
	// Fails in WebKit before Feb 2011 nightlies\n\
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\
	if ( document.defaultView && document.defaultView.getComputedStyle ) {\n\
		marginDiv = document.createElement( \"div\" );\n\
		marginDiv.style.width = \"0\";\n\
		marginDiv.style.marginRight = \"0\";\n\
		div.appendChild( marginDiv );\n\
		support.reliableMarginRight =\n\
			( parseInt( ( document.defaultView.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;\n\
	}\n\
\n\
	// Remove the body element we added\n\
	testElement.innerHTML = \"\";\n\
	testElementParent.removeChild( testElement );\n\
\n\
	// Technique from Juriy Zaytsev\n\
	// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/\n\
	// We only care about the case where non-standard event systems\n\
	// are used, namely in IE. Short-circuiting here helps us to\n\
	// avoid an eval call (in setAttribute) which can cause CSP\n\
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP\n\
	if ( div.attachEvent ) {\n\
		for( i in {\n\
			submit: 1,\n\
			change: 1,\n\
			focusin: 1\n\
		} ) {\n\
			eventName = \"on\" + i;\n\
			isSupported = ( eventName in div );\n\
			if ( !isSupported ) {\n\
				div.setAttribute( eventName, \"return;\" );\n\
				isSupported = ( typeof div[ eventName ] === \"function\" );\n\
			}\n\
			support[ i + \"Bubbles\" ] = isSupported;\n\
		}\n\
	}\n\
\n\
	// Null connected elements to avoid leaks in IE\n\
	testElement = fragment = select = opt = body = marginDiv = div = input = null;\n\
\n\
	return support;\n\
})();\n\
\n\
// Keep track of boxModel\n\
jQuery.boxModel = jQuery.support.boxModel;\n\
\n\
\n\
\n\
\n\
var rbrace = /^(?:\\{.*\\}|\\[.*\\])$/,\n\
	rmultiDash = /([A-Z])/g;\n\
\n\
jQuery.extend({\n\
	cache: {},\n\
\n\
	// Please use with caution\n\
	uuid: 0,\n\
\n\
	// Unique for each copy of jQuery on the page\n\
	// Non-digits removed to match rinlinejQuery\n\
	expando: \"jQuery\" + ( jQuery.fn.jquery + Math.random() ).replace( /\\D/g, \"\" ),\n\
\n\
	// The following elements throw uncatchable exceptions if you\n\
	// attempt to add expando properties to them.\n\
	noData: {\n\
		\"embed\": true,\n\
		// Ban all objects except for Flash (which handle expandos)\n\
		\"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n\
		\"applet\": true\n\
	},\n\
\n\
	hasData: function( elem ) {\n\
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\
\n\
		return !!elem && !isEmptyDataObject( elem );\n\
	},\n\
\n\
	data: function( elem, name, data, pvt /* Internal Use Only */ ) {\n\
		if ( !jQuery.acceptData( elem ) ) {\n\
			return;\n\
		}\n\
\n\
		var thisCache, ret,\n\
			internalKey = jQuery.expando,\n\
			getByName = typeof name === \"string\",\n\
\n\
			// We have to handle DOM nodes and JS objects differently because IE6-7\n\
			// can't GC object references properly across the DOM-JS boundary\n\
			isNode = elem.nodeType,\n\
\n\
			// Only DOM nodes need the global jQuery cache; JS object data is\n\
			// attached directly to the object so GC can occur automatically\n\
			cache = isNode ? jQuery.cache : elem,\n\
\n\
			// Only defining an ID for JS objects if its cache already exists allows\n\
			// the code to shortcut on the same path as a DOM node with no cache\n\
			id = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && jQuery.expando;\n\
\n\
		// Avoid doing any more work than we need to when trying to get data on an\n\
		// object that has no data at all\n\
		if ( (!id || (pvt && id && (cache[ id ] && !cache[ id ][ internalKey ]))) && getByName && data === undefined ) {\n\
			return;\n\
		}\n\
\n\
		if ( !id ) {\n\
			// Only DOM nodes need a new unique ID for each element since their data\n\
			// ends up in the global cache\n\
			if ( isNode ) {\n\
				elem[ jQuery.expando ] = id = ++jQuery.uuid;\n\
			} else {\n\
				id = jQuery.expando;\n\
			}\n\
		}\n\
\n\
		if ( !cache[ id ] ) {\n\
			cache[ id ] = {};\n\
\n\
			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery\n\
			// metadata on plain JS objects when the object is serialized using\n\
			// JSON.stringify\n\
			if ( !isNode ) {\n\
				cache[ id ].toJSON = jQuery.noop;\n\
			}\n\
		}\n\
\n\
		// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\
		// shallow copied over onto the existing cache\n\
		if ( typeof name === \"object\" || typeof name === \"function\" ) {\n\
			if ( pvt ) {\n\
				cache[ id ][ internalKey ] = jQuery.extend(cache[ id ][ internalKey ], name);\n\
			} else {\n\
				cache[ id ] = jQuery.extend(cache[ id ], name);\n\
			}\n\
		}\n\
\n\
		thisCache = cache[ id ];\n\
\n\
		// Internal jQuery data is stored in a separate object inside the object's data\n\
		// cache in order to avoid key collisions between internal data and user-defined\n\
		// data\n\
		if ( pvt ) {\n\
			if ( !thisCache[ internalKey ] ) {\n\
				thisCache[ internalKey ] = {};\n\
			}\n\
\n\
			thisCache = thisCache[ internalKey ];\n\
		}\n\
\n\
		if ( data !== undefined ) {\n\
			thisCache[ jQuery.camelCase( name ) ] = data;\n\
		}\n\
\n\
		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should\n\
		// not attempt to inspect the internal events object using jQuery.data, as this\n\
		// internal data object is undocumented and subject to change.\n\
		if ( name === \"events\" && !thisCache[name] ) {\n\
			return thisCache[ internalKey ] && thisCache[ internalKey ].events;\n\
		}\n\
\n\
		// Check for both converted-to-camel and non-converted data property names\n\
		// If a data property was specified\n\
		if ( getByName ) {\n\
\n\
			// First Try to find as-is property data\n\
			ret = thisCache[ name ];\n\
\n\
			// Test for null|undefined property data\n\
			if ( ret == null ) {\n\
\n\
				// Try to find the camelCased property\n\
				ret = thisCache[ jQuery.camelCase( name ) ];\n\
			}\n\
		} else {\n\
			ret = thisCache;\n\
		}\n\
\n\
		return ret;\n\
	},\n\
\n\
	removeData: function( elem, name, pvt /* Internal Use Only */ ) {\n\
		if ( !jQuery.acceptData( elem ) ) {\n\
			return;\n\
		}\n\
\n\
		var thisCache,\n\
\n\
			// Reference to internal data cache key\n\
			internalKey = jQuery.expando,\n\
\n\
			isNode = elem.nodeType,\n\
\n\
			// See jQuery.data for more information\n\
			cache = isNode ? jQuery.cache : elem,\n\
\n\
			// See jQuery.data for more information\n\
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\
\n\
		// If there is already no cache entry for this object, there is no\n\
		// purpose in continuing\n\
		if ( !cache[ id ] ) {\n\
			return;\n\
		}\n\
\n\
		if ( name ) {\n\
\n\
			thisCache = pvt ? cache[ id ][ internalKey ] : cache[ id ];\n\
\n\
			if ( thisCache ) {\n\
\n\
				// Support interoperable removal of hyphenated or camelcased keys\n\
				if ( !thisCache[ name ] ) {\n\
					name = jQuery.camelCase( name );\n\
				}\n\
\n\
				delete thisCache[ name ];\n\
\n\
				// If there is no data left in the cache, we want to continue\n\
				// and let the cache object itself get destroyed\n\
				if ( !isEmptyDataObject(thisCache) ) {\n\
					return;\n\
				}\n\
			}\n\
		}\n\
\n\
		// See jQuery.data for more information\n\
		if ( pvt ) {\n\
			delete cache[ id ][ internalKey ];\n\
\n\
			// Don't destroy the parent cache unless the internal data object\n\
			// had been the only thing left in it\n\
			if ( !isEmptyDataObject(cache[ id ]) ) {\n\
				return;\n\
			}\n\
		}\n\
\n\
		var internalCache = cache[ id ][ internalKey ];\n\
\n\
		// Browsers that fail expando deletion also refuse to delete expandos on\n\
		// the window, but it will allow it on all other JS objects; other browsers\n\
		// don't care\n\
		// Ensure that `cache` is not a window object #10080\n\
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {\n\
			delete cache[ id ];\n\
		} else {\n\
			cache[ id ] = null;\n\
		}\n\
\n\
		// We destroyed the entire user cache at once because it's faster than\n\
		// iterating through each key, but we need to continue to persist internal\n\
		// data if it existed\n\
		if ( internalCache ) {\n\
			cache[ id ] = {};\n\
			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery\n\
			// metadata on plain JS objects when the object is serialized using\n\
			// JSON.stringify\n\
			if ( !isNode ) {\n\
				cache[ id ].toJSON = jQuery.noop;\n\
			}\n\
\n\
			cache[ id ][ internalKey ] = internalCache;\n\
\n\
		// Otherwise, we need to eliminate the expando on the node to avoid\n\
		// false lookups in the cache for entries that no longer exist\n\
		} else if ( isNode ) {\n\
			// IE does not allow us to delete expando properties from nodes,\n\
			// nor does it have a removeAttribute function on Document nodes;\n\
			// we must handle all of these cases\n\
			if ( jQuery.support.deleteExpando ) {\n\
				delete elem[ jQuery.expando ];\n\
			} else if ( elem.removeAttribute ) {\n\
				elem.removeAttribute( jQuery.expando );\n\
			} else {\n\
				elem[ jQuery.expando ] = null;\n\
			}\n\
		}\n\
	},\n\
\n\
	// For internal use only.\n\
	_data: function( elem, name, data ) {\n\
		return jQuery.data( elem, name, data, true );\n\
	},\n\
\n\
	// A method for determining if a DOM node can handle the data expando\n\
	acceptData: function( elem ) {\n\
		if ( elem.nodeName ) {\n\
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];\n\
\n\
			if ( match ) {\n\
				return !(match === true || elem.getAttribute(\"classid\") !== match);\n\
			}\n\
		}\n\
\n\
		return true;\n\
	}\n\
});\n\
\n\
jQuery.fn.extend({\n\
	data: function( key, value ) {\n\
		var data = null;\n\
\n\
		if ( typeof key === \"undefined\" ) {\n\
			if ( this.length ) {\n\
				data = jQuery.data( this[0] );\n\
\n\
				if ( this[0].nodeType === 1 ) {\n\
			    var attr = this[0].attributes, name;\n\
					for ( var i = 0, l = attr.length; i < l; i++ ) {\n\
						name = attr[i].name;\n\
\n\
						if ( name.indexOf( \"data-\" ) === 0 ) {\n\
							name = jQuery.camelCase( name.substring(5) );\n\
\n\
							dataAttr( this[0], name, data[ name ] );\n\
						}\n\
					}\n\
				}\n\
			}\n\
\n\
			return data;\n\
\n\
		} else if ( typeof key === \"object\" ) {\n\
			return this.each(function() {\n\
				jQuery.data( this, key );\n\
			});\n\
		}\n\
\n\
		var parts = key.split(\".\");\n\
		parts[1] = parts[1] ? \".\" + parts[1] : \"\";\n\
\n\
		if ( value === undefined ) {\n\
			data = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]);\n\
\n\
			// Try to fetch any internally stored data first\n\
			if ( data === undefined && this.length ) {\n\
				data = jQuery.data( this[0], key );\n\
				data = dataAttr( this[0], key, data );\n\
			}\n\
\n\
			return data === undefined && parts[1] ?\n\
				this.data( parts[0] ) :\n\
				data;\n\
\n\
		} else {\n\
			return this.each(function() {\n\
				var $this = jQuery( this ),\n\
					args = [ parts[0], value ];\n\
\n\
				$this.triggerHandler( \"setData\" + parts[1] + \"!\", args );\n\
				jQuery.data( this, key, value );\n\
				$this.triggerHandler( \"changeData\" + parts[1] + \"!\", args );\n\
			});\n\
		}\n\
	},\n\
\n\
	removeData: function( key ) {\n\
		return this.each(function() {\n\
			jQuery.removeData( this, key );\n\
		});\n\
	}\n\
});\n\
\n\
function dataAttr( elem, key, data ) {\n\
	// If nothing was found internally, try to fetch any\n\
	// data from the HTML5 data-* attribute\n\
	if ( data === undefined && elem.nodeType === 1 ) {\n\
\n\
		var name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\
\n\
		data = elem.getAttribute( name );\n\
\n\
		if ( typeof data === \"string\" ) {\n\
			try {\n\
				data = data === \"true\" ? true :\n\
				data === \"false\" ? false :\n\
				data === \"null\" ? null :\n\
				!jQuery.isNaN( data ) ? parseFloat( data ) :\n\
					rbrace.test( data ) ? jQuery.parseJSON( data ) :\n\
					data;\n\
			} catch( e ) {}\n\
\n\
			// Make sure we set the data so it isn't changed later\n\
			jQuery.data( elem, key, data );\n\
\n\
		} else {\n\
			data = undefined;\n\
		}\n\
	}\n\
\n\
	return data;\n\
}\n\
\n\
// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON\n\
// property to be considered empty objects; this property always exists in\n\
// order to make sure JSON.stringify does not expose internal metadata\n\
function isEmptyDataObject( obj ) {\n\
	for ( var name in obj ) {\n\
		if ( name !== \"toJSON\" ) {\n\
			return false;\n\
		}\n\
	}\n\
\n\
	return true;\n\
}\n\
\n\
\n\
\n\
\n\
function handleQueueMarkDefer( elem, type, src ) {\n\
	var deferDataKey = type + \"defer\",\n\
		queueDataKey = type + \"queue\",\n\
		markDataKey = type + \"mark\",\n\
		defer = jQuery.data( elem, deferDataKey, undefined, true );\n\
	if ( defer &&\n\
		( src === \"queue\" || !jQuery.data( elem, queueDataKey, undefined, true ) ) &&\n\
		( src === \"mark\" || !jQuery.data( elem, markDataKey, undefined, true ) ) ) {\n\
		// Give room for hard-coded callbacks to fire first\n\
		// and eventually mark/queue something else on the element\n\
		setTimeout( function() {\n\
			if ( !jQuery.data( elem, queueDataKey, undefined, true ) &&\n\
				!jQuery.data( elem, markDataKey, undefined, true ) ) {\n\
				jQuery.removeData( elem, deferDataKey, true );\n\
				defer.resolve();\n\
			}\n\
		}, 0 );\n\
	}\n\
}\n\
\n\
jQuery.extend({\n\
\n\
	_mark: function( elem, type ) {\n\
		if ( elem ) {\n\
			type = (type || \"fx\") + \"mark\";\n\
			jQuery.data( elem, type, (jQuery.data(elem,type,undefined,true) || 0) + 1, true );\n\
		}\n\
	},\n\
\n\
	_unmark: function( force, elem, type ) {\n\
		if ( force !== true ) {\n\
			type = elem;\n\
			elem = force;\n\
			force = false;\n\
		}\n\
		if ( elem ) {\n\
			type = type || \"fx\";\n\
			var key = type + \"mark\",\n\
				count = force ? 0 : ( (jQuery.data( elem, key, undefined, true) || 1 ) - 1 );\n\
			if ( count ) {\n\
				jQuery.data( elem, key, count, true );\n\
			} else {\n\
				jQuery.removeData( elem, key, true );\n\
				handleQueueMarkDefer( elem, type, \"mark\" );\n\
			}\n\
		}\n\
	},\n\
\n\
	queue: function( elem, type, data ) {\n\
		if ( elem ) {\n\
			type = (type || \"fx\") + \"queue\";\n\
			var q = jQuery.data( elem, type, undefined, true );\n\
			// Speed up dequeue by getting out quickly if this is just a lookup\n\
			if ( data ) {\n\
				if ( !q || jQuery.isArray(data) ) {\n\
					q = jQuery.data( elem, type, jQuery.makeArray(data), true );\n\
				} else {\n\
					q.push( data );\n\
				}\n\
			}\n\
			return q || [];\n\
		}\n\
	},\n\
\n\
	dequeue: function( elem, type ) {\n\
		type = type || \"fx\";\n\
\n\
		var queue = jQuery.queue( elem, type ),\n\
			fn = queue.shift(),\n\
			defer;\n\
\n\
		// If the fx queue is dequeued, always remove the progress sentinel\n\
		if ( fn === \"inprogress\" ) {\n\
			fn = queue.shift();\n\
		}\n\
\n\
		if ( fn ) {\n\
			// Add a progress sentinel to prevent the fx queue from being\n\
			// automatically dequeued\n\
			if ( type === \"fx\" ) {\n\
				queue.unshift(\"inprogress\");\n\
			}\n\
\n\
			fn.call(elem, function() {\n\
				jQuery.dequeue(elem, type);\n\
			});\n\
		}\n\
\n\
		if ( !queue.length ) {\n\
			jQuery.removeData( elem, type + \"queue\", true );\n\
			handleQueueMarkDefer( elem, type, \"queue\" );\n\
		}\n\
	}\n\
});\n\
\n\
jQuery.fn.extend({\n\
	queue: function( type, data ) {\n\
		if ( typeof type !== \"string\" ) {\n\
			data = type;\n\
			type = \"fx\";\n\
		}\n\
\n\
		if ( data === undefined ) {\n\
			return jQuery.queue( this[0], type );\n\
		}\n\
		return this.each(function() {\n\
			var queue = jQuery.queue( this, type, data );\n\
\n\
			if ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\
				jQuery.dequeue( this, type );\n\
			}\n\
		});\n\
	},\n\
	dequeue: function( type ) {\n\
		return this.each(function() {\n\
			jQuery.dequeue( this, type );\n\
		});\n\
	},\n\
	// Based off of the plugin by Clint Helfers, with permission.\n\
	// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\
	delay: function( time, type ) {\n\
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n\
		type = type || \"fx\";\n\
\n\
		return this.queue( type, function() {\n\
			var elem = this;\n\
			setTimeout(function() {\n\
				jQuery.dequeue( elem, type );\n\
			}, time );\n\
		});\n\
	},\n\
	clearQueue: function( type ) {\n\
		return this.queue( type || \"fx\", [] );\n\
	},\n\
	// Get a promise resolved when queues of a certain type\n\
	// are emptied (fx is the type by default)\n\
	promise: function( type, object ) {\n\
		if ( typeof type !== \"string\" ) {\n\
			object = type;\n\
			type = undefined;\n\
		}\n\
		type = type || \"fx\";\n\
		var defer = jQuery.Deferred(),\n\
			elements = this,\n\
			i = elements.length,\n\
			count = 1,\n\
			deferDataKey = type + \"defer\",\n\
			queueDataKey = type + \"queue\",\n\
			markDataKey = type + \"mark\",\n\
			tmp;\n\
		function resolve() {\n\
			if ( !( --count ) ) {\n\
				defer.resolveWith( elements, [ elements ] );\n\
			}\n\
		}\n\
		while( i-- ) {\n\
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||\n\
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||\n\
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&\n\
					jQuery.data( elements[ i ], deferDataKey, jQuery._Deferred(), true ) )) {\n\
				count++;\n\
				tmp.done( resolve );\n\
			}\n\
		}\n\
		resolve();\n\
		return defer.promise();\n\
	}\n\
});\n\
\n\
\n\
\n\
\n\
var rclass = /[\\n\\t\\r]/g,\n\
	rspace = /\\s+/,\n\
	rreturn = /\\r/g,\n\
	rtype = /^(?:button|input)$/i,\n\
	rfocusable = /^(?:button|input|object|select|textarea)$/i,\n\
	rclickable = /^a(?:rea)?$/i,\n\
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,\n\
	nodeHook, boolHook;\n\
\n\
jQuery.fn.extend({\n\
	attr: function( name, value ) {\n\
		return jQuery.access( this, name, value, true, jQuery.attr );\n\
	},\n\
\n\
	removeAttr: function( name ) {\n\
		return this.each(function() {\n\
			jQuery.removeAttr( this, name );\n\
		});\n\
	},\n\
	\n\
	prop: function( name, value ) {\n\
		return jQuery.access( this, name, value, true, jQuery.prop );\n\
	},\n\
	\n\
	removeProp: function( name ) {\n\
		name = jQuery.propFix[ name ] || name;\n\
		return this.each(function() {\n\
			// try/catch handles cases where IE balks (such as removing a property on window)\n\
			try {\n\
				this[ name ] = undefined;\n\
				delete this[ name ];\n\
			} catch( e ) {}\n\
		});\n\
	},\n\
\n\
	addClass: function( value ) {\n\
		var classNames, i, l, elem,\n\
			setClass, c, cl;\n\
\n\
		if ( jQuery.isFunction( value ) ) {\n\
			return this.each(function( j ) {\n\
				jQuery( this ).addClass( value.call(this, j, this.className) );\n\
			});\n\
		}\n\
\n\
		if ( value && typeof value === \"string\" ) {\n\
			classNames = value.split( rspace );\n\
\n\
			for ( i = 0, l = this.length; i < l; i++ ) {\n\
				elem = this[ i ];\n\
\n\
				if ( elem.nodeType === 1 ) {\n\
					if ( !elem.className && classNames.length === 1 ) {\n\
						elem.className = value;\n\
\n\
					} else {\n\
						setClass = \" \" + elem.className + \" \";\n\
\n\
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {\n\
							if ( !~setClass.indexOf( \" \" + classNames[ c ] + \" \" ) ) {\n\
								setClass += classNames[ c ] + \" \";\n\
							}\n\
						}\n\
						elem.className = jQuery.trim( setClass );\n\
					}\n\
				}\n\
			}\n\
		}\n\
\n\
		return this;\n\
	},\n\
\n\
	removeClass: function( value ) {\n\
		var classNames, i, l, elem, className, c, cl;\n\
\n\
		if ( jQuery.isFunction( value ) ) {\n\
			return this.each(function( j ) {\n\
				jQuery( this ).removeClass( value.call(this, j, this.className) );\n\
			});\n\
		}\n\
\n\
		if ( (value && typeof value === \"string\") || value === undefined ) {\n\
			classNames = (value || \"\").split( rspace );\n\
\n\
			for ( i = 0, l = this.length; i < l; i++ ) {\n\
				elem = this[ i ];\n\
\n\
				if ( elem.nodeType === 1 && elem.className ) {\n\
					if ( value ) {\n\
						className = (\" \" + elem.className + \" \").replace( rclass, \" \" );\n\
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {\n\
							className = className.replace(\" \" + classNames[ c ] + \" \", \" \");\n\
						}\n\
						elem.className = jQuery.trim( className );\n\
\n\
					} else {\n\
						elem.className = \"\";\n\
					}\n\
				}\n\
			}\n\
		}\n\
\n\
		return this;\n\
	},\n\
\n\
	toggleClass: function( value, stateVal ) {\n\
		var type = typeof value,\n\
			isBool = typeof stateVal === \"boolean\";\n\
\n\
		if ( jQuery.isFunction( value ) ) {\n\
			return this.each(function( i ) {\n\
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\
			});\n\
		}\n\
\n\
		return this.each(function() {\n\
			if ( type === \"string\" ) {\n\
				// toggle individual class names\n\
				var className,\n\
					i = 0,\n\
					self = jQuery( this ),\n\
					state = stateVal,\n\
					classNames = value.split( rspace );\n\
\n\
				while ( (className = classNames[ i++ ]) ) {\n\
					// check each className given, space seperated list\n\
					state = isBool ? state : !self.hasClass( className );\n\
					self[ state ? \"addClass\" : \"removeClass\" ]( className );\n\
				}\n\
\n\
			} else if ( type === \"undefined\" || type === \"boolean\" ) {\n\
				if ( this.className ) {\n\
					// store className if set\n\
					jQuery._data( this, \"__className__\", this.className );\n\
				}\n\
\n\
				// toggle whole className\n\
				this.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\
			}\n\
		});\n\
	},\n\
\n\
	hasClass: function( selector ) {\n\
		var className = \" \" + selector + \" \";\n\
		for ( var i = 0, l = this.length; i < l; i++ ) {\n\
			if ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) > -1 ) {\n\
				return true;\n\
			}\n\
		}\n\
\n\
		return false;\n\
	},\n\
\n\
	val: function( value ) {\n\
		var hooks, ret,\n\
			elem = this[0];\n\
		\n\
		if ( !arguments.length ) {\n\
			if ( elem ) {\n\
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];\n\
\n\
				if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\
					return ret;\n\
				}\n\
\n\
				ret = elem.value;\n\
\n\
				return typeof ret === \"string\" ? \n\
					// handle most common string cases\n\
					ret.replace(rreturn, \"\") : \n\
					// handle cases where value is null/undef or number\n\
					ret == null ? \"\" : ret;\n\
			}\n\
\n\
			return undefined;\n\
		}\n\
\n\
		var isFunction = jQuery.isFunction( value );\n\
\n\
		return this.each(function( i ) {\n\
			var self = jQuery(this), val;\n\
\n\
			if ( this.nodeType !== 1 ) {\n\
				return;\n\
			}\n\
\n\
			if ( isFunction ) {\n\
				val = value.call( this, i, self.val() );\n\
			} else {\n\
				val = value;\n\
			}\n\
\n\
			// Treat null/undefined as \"\"; convert numbers to string\n\
			if ( val == null ) {\n\
				val = \"\";\n\
			} else if ( typeof val === \"number\" ) {\n\
				val += \"\";\n\
			} else if ( jQuery.isArray( val ) ) {\n\
				val = jQuery.map(val, function ( value ) {\n\
					return value == null ? \"\" : value + \"\";\n\
				});\n\
			}\n\
\n\
			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];\n\
\n\
			// If set returns undefined, fall back to normal setting\n\
			if ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\
				this.value = val;\n\
			}\n\
		});\n\
	}\n\
});\n\
\n\
jQuery.extend({\n\
	valHooks: {\n\
		option: {\n\
			get: function( elem ) {\n\
				// attributes.value is undefined in Blackberry 4.7 but\n\
				// uses .value. See #6932\n\
				var val = elem.attributes.value;\n\
				return !val || val.specified ? elem.value : elem.text;\n\
			}\n\
		},\n\
		select: {\n\
			get: function( elem ) {\n\
				var value,\n\
					index = elem.selectedIndex,\n\
					values = [],\n\
					options = elem.options,\n\
					one = elem.type === \"select-one\";\n\
\n\
				// Nothing was selected\n\
				if ( index < 0 ) {\n\
					return null;\n\
				}\n\
\n\
				// Loop through all the selected options\n\
				for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {\n\
					var option = options[ i ];\n\
\n\
					// Don't return options that are disabled or in a disabled optgroup\n\
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) &&\n\
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" )) ) {\n\
\n\
						// Get the specific value for the option\n\
						value = jQuery( option ).val();\n\
\n\
						// We don't need an array for one selects\n\
						if ( one ) {\n\
							return value;\n\
						}\n\
\n\
						// Multi-Selects return an array\n\
						values.push( value );\n\
					}\n\
				}\n\
\n\
				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()\n\
				if ( one && !values.length && options.length ) {\n\
					return jQuery( options[ index ] ).val();\n\
				}\n\
\n\
				return values;\n\
			},\n\
\n\
			set: function( elem, value ) {\n\
				var values = jQuery.makeArray( value );\n\
\n\
				jQuery(elem).find(\"option\").each(function() {\n\
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;\n\
				});\n\
\n\
				if ( !values.length ) {\n\
					elem.selectedIndex = -1;\n\
				}\n\
				return values;\n\
			}\n\
		}\n\
	},\n\
\n\
	attrFn: {\n\
		val: true,\n\
		css: true,\n\
		html: true,\n\
		text: true,\n\
		data: true,\n\
		width: true,\n\
		height: true,\n\
		offset: true\n\
	},\n\
	\n\
	attrFix: {\n\
		// Always normalize to ensure hook usage\n\
		tabindex: \"tabIndex\"\n\
	},\n\
	\n\
	attr: function( elem, name, value, pass ) {\n\
		var nType = elem.nodeType;\n\
		\n\
		// don't get/set attributes on text, comment and attribute nodes\n\
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\
			return undefined;\n\
		}\n\
\n\
		if ( pass && name in jQuery.attrFn ) {\n\
			return jQuery( elem )[ name ]( value );\n\
		}\n\
\n\
		// Fallback to prop when attributes are not supported\n\
		if ( !(\"getAttribute\" in elem) ) {\n\
			return jQuery.prop( elem, name, value );\n\
		}\n\
\n\
		var ret, hooks,\n\
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\
\n\
		// Normalize the name if needed\n\
		if ( notxml ) {\n\
			name = jQuery.attrFix[ name ] || name;\n\
\n\
			hooks = jQuery.attrHooks[ name ];\n\
\n\
			if ( !hooks ) {\n\
				// Use boolHook for boolean attributes\n\
				if ( rboolean.test( name ) ) {\n\
					hooks = boolHook;\n\
\n\
				// Use nodeHook if available( IE6/7 )\n\
				} else if ( nodeHook ) {\n\
					hooks = nodeHook;\n\
				}\n\
			}\n\
		}\n\
\n\
		if ( value !== undefined ) {\n\
\n\
			if ( value === null ) {\n\
				jQuery.removeAttr( elem, name );\n\
				return undefined;\n\
\n\
			} else if ( hooks && \"set\" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\
				return ret;\n\
\n\
			} else {\n\
				elem.setAttribute( name, \"\" + value );\n\
				return value;\n\
			}\n\
\n\
		} else if ( hooks && \"get\" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {\n\
			return ret;\n\
\n\
		} else {\n\
\n\
			ret = elem.getAttribute( name );\n\
\n\
			// Non-existent attributes return null, we normalize to undefined\n\
			return ret === null ?\n\
				undefined :\n\
				ret;\n\
		}\n\
	},\n\
\n\
	removeAttr: function( elem, name ) {\n\
		var propName;\n\
		if ( elem.nodeType === 1 ) {\n\
			name = jQuery.attrFix[ name ] || name;\n\
\n\
			jQuery.attr( elem, name, \"\" );\n\
			elem.removeAttribute( name );\n\
\n\
			// Set corresponding property to false for boolean attributes\n\
			if ( rboolean.test( name ) && (propName = jQuery.propFix[ name ] || name) in elem ) {\n\
				elem[ propName ] = false;\n\
			}\n\
		}\n\
	},\n\
\n\
	attrHooks: {\n\
		type: {\n\
			set: function( elem, value ) {\n\
				// We can't allow the type property to be changed (since it causes problems in IE)\n\
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {\n\
					jQuery.error( \"type property can't be changed\" );\n\
				} else if ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\
					// Setting the type on a radio button after the value resets the value in IE6-9\n\
					// Reset value to it's default in case type is set after value\n\
					// This is for element creation\n\
					var val = elem.value;\n\
					elem.setAttribute( \"type\", value );\n\
					if ( val ) {\n\
						elem.value = val;\n\
					}\n\
					return value;\n\
				}\n\
			}\n\
		},\n\
		// Use the value property for back compat\n\
		// Use the nodeHook for button elements in IE6/7 (#1954)\n\
		value: {\n\
			get: function( elem, name ) {\n\
				if ( nodeHook && jQuery.nodeName( elem, \"button\" ) ) {\n\
					return nodeHook.get( elem, name );\n\
				}\n\
				return name in elem ?\n\
					elem.value :\n\
					null;\n\
			},\n\
			set: function( elem, value, name ) {\n\
				if ( nodeHook && jQuery.nodeName( elem, \"button\" ) ) {\n\
					return nodeHook.set( elem, value, name );\n\
				}\n\
				// Does not return so that setAttribute is also used\n\
				elem.value = value;\n\
			}\n\
		}\n\
	},\n\
\n\
	propFix: {\n\
		tabindex: \"tabIndex\",\n\
		readonly: \"readOnly\",\n\
		\"for\": \"htmlFor\",\n\
		\"class\": \"className\",\n\
		maxlength: \"maxLength\",\n\
		cellspacing: \"cellSpacing\",\n\
		cellpadding: \"cellPadding\",\n\
		rowspan: \"rowSpan\",\n\
		colspan: \"colSpan\",\n\
		usemap: \"useMap\",\n\
		frameborder: \"frameBorder\",\n\
		contenteditable: \"contentEditable\"\n\
	},\n\
	\n\
	prop: function( elem, name, value ) {\n\
		var nType = elem.nodeType;\n\
\n\
		// don't get/set properties on text, comment and attribute nodes\n\
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\
			return undefined;\n\
		}\n\
\n\
		var ret, hooks,\n\
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\
\n\
		if ( notxml ) {\n\
			// Fix name and attach hooks\n\
			name = jQuery.propFix[ name ] || name;\n\
			hooks = jQuery.propHooks[ name ];\n\
		}\n\
\n\
		if ( value !== undefined ) {\n\
			if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\
				return ret;\n\
\n\
			} else {\n\
				return (elem[ name ] = value);\n\
			}\n\
\n\
		} else {\n\
			if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\
				return ret;\n\
\n\
			} else {\n\
				return elem[ name ];\n\
			}\n\
		}\n\
	},\n\
	\n\
	propHooks: {\n\
		tabIndex: {\n\
			get: function( elem ) {\n\
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\
				var attributeNode = elem.getAttributeNode(\"tabindex\");\n\
\n\
				return attributeNode && attributeNode.specified ?\n\
					parseInt( attributeNode.value, 10 ) :\n\
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\
						0 :\n\
						undefined;\n\
			}\n\
		}\n\
	}\n\
});\n\
\n\
// Add the tabindex propHook to attrHooks for back-compat\n\
jQuery.attrHooks.tabIndex = jQuery.propHooks.tabIndex;\n\
\n\
// Hook for boolean attributes\n\
boolHook = {\n\
	get: function( elem, name ) {\n\
		// Align boolean attributes with corresponding properties\n\
		// Fall back to attribute presence where some booleans are not supported\n\
		var attrNode;\n\
		return jQuery.prop( elem, name ) === true || ( attrNode = elem.getAttributeNode( name ) ) && attrNode.nodeValue !== false ?\n\
			name.toLowerCase() :\n\
			undefined;\n\
	},\n\
	set: function( elem, value, name ) {\n\
		var propName;\n\
		if ( value === false ) {\n\
			// Remove boolean attributes when set to false\n\
			jQuery.removeAttr( elem, name );\n\
		} else {\n\
			// value is true since we know at this point it's type boolean and not false\n\
			// Set boolean attributes to the same name and set the DOM property\n\
			propName = jQuery.propFix[ name ] || name;\n\
			if ( propName in elem ) {\n\
				// Only set the IDL specifically if it already exists on the element\n\
				elem[ propName ] = true;\n\
			}\n\
\n\
			elem.setAttribute( name, name.toLowerCase() );\n\
		}\n\
		return name;\n\
	}\n\
};\n\
\n\
// IE6/7 do not support getting/setting some attributes with get/setAttribute\n\
if ( !jQuery.support.getSetAttribute ) {\n\
	\n\
	// Use this for any attribute in IE6/7\n\
	// This fixes almost every IE6/7 issue\n\
	nodeHook = jQuery.valHooks.button = {\n\
		get: function( elem, name ) {\n\
			var ret;\n\
			ret = elem.getAttributeNode( name );\n\
			// Return undefined if nodeValue is empty string\n\
			return ret && ret.nodeValue !== \"\" ?\n\
				ret.nodeValue :\n\
				undefined;\n\
		},\n\
		set: function( elem, value, name ) {\n\
			// Set the existing or create a new attribute node\n\
			var ret = elem.getAttributeNode( name );\n\
			if ( !ret ) {\n\
				ret = document.createAttribute( name );\n\
				elem.setAttributeNode( ret );\n\
			}\n\
			return (ret.nodeValue = value + \"\");\n\
		}\n\
	};\n\
\n\
	// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\
	// This is for removals\n\
	jQuery.each([ \"width\", \"height\" ], function( i, name ) {\n\
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\
			set: function( elem, value ) {\n\
				if ( value === \"\" ) {\n\
					elem.setAttribute( name, \"auto\" );\n\
					return value;\n\
				}\n\
			}\n\
		});\n\
	});\n\
}\n\
\n\
\n\
// Some attributes require a special call on IE\n\
if ( !jQuery.support.hrefNormalized ) {\n\
	jQuery.each([ \"href\", \"src\", \"width\", \"height\" ], function( i, name ) {\n\
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\
			get: function( elem ) {\n\
				var ret = elem.getAttribute( name, 2 );\n\
				return ret === null ? undefined : ret;\n\
			}\n\
		});\n\
	});\n\
}\n\
\n\
if ( !jQuery.support.style ) {\n\
	jQuery.attrHooks.style = {\n\
		get: function( elem ) {\n\
			// Return undefined in the case of empty string\n\
			// Normalize to lowercase since IE uppercases css property names\n\
			return elem.style.cssText.toLowerCase() || undefined;\n\
		},\n\
		set: function( elem, value ) {\n\
			return (elem.style.cssText = \"\" + value);\n\
		}\n\
	};\n\
}\n\
\n\
// Safari mis-reports the default selected property of an option\n\
// Accessing the parent's selectedIndex property fixes it\n\
if ( !jQuery.support.optSelected ) {\n\
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {\n\
		get: function( elem ) {\n\
			var parent = elem.parentNode;\n\
\n\
			if ( parent ) {\n\
				parent.selectedIndex;\n\
\n\
				// Make sure that it also works with optgroups, see #5701\n\
				if ( parent.parentNode ) {\n\
					parent.parentNode.selectedIndex;\n\
				}\n\
			}\n\
			return null;\n\
		}\n\
	});\n\
}\n\
\n\
// Radios and checkboxes getter/setter\n\
if ( !jQuery.support.checkOn ) {\n\
	jQuery.each([ \"radio\", \"checkbox\" ], function() {\n\
		jQuery.valHooks[ this ] = {\n\
			get: function( elem ) {\n\
				// Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n\
				return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\
			}\n\
		};\n\
	});\n\
}\n\
jQuery.each([ \"radio\", \"checkbox\" ], function() {\n\
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {\n\
		set: function( elem, value ) {\n\
			if ( jQuery.isArray( value ) ) {\n\
				return (elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0);\n\
			}\n\
		}\n\
	});\n\
});\n\
\n\
\n\
\n\
\n\
var rnamespaces = /\\.(.*)$/,\n\
	rformElems = /^(?:textarea|input|select)$/i,\n\
	rperiod = /\\./g,\n\
	rspaces = / /g,\n\
	rescape = /[^\\w\\s.|`]/g,\n\
	fcleanup = function( nm ) {\n\
		return nm.replace(rescape, \"\\\\$&\");\n\
	};\n\
\n\
/*\n\
 * A number of helper functions used for managing events.\n\
 * Many of the ideas behind this code originated from\n\
 * Dean Edwards' addEvent library.\n\
 */\n\
jQuery.event = {\n\
\n\
	// Bind an event to an element\n\
	// Original by Dean Edwards\n\
	add: function( elem, types, handler, data ) {\n\
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\
			return;\n\
		}\n\
\n\
		if ( handler === false ) {\n\
			handler = returnFalse;\n\
		} else if ( !handler ) {\n\
			// Fixes bug #7229. Fix recommended by jdalton\n\
			return;\n\
		}\n\
\n\
		var handleObjIn, handleObj;\n\
\n\
		if ( handler.handler ) {\n\
			handleObjIn = handler;\n\
			handler = handleObjIn.handler;\n\
		}\n\
\n\
		// Make sure that the function being executed has a unique ID\n\
		if ( !handler.guid ) {\n\
			handler.guid = jQuery.guid++;\n\
		}\n\
\n\
		// Init the element's event structure\n\
		var elemData = jQuery._data( elem );\n\
\n\
		// If no elemData is found then we must be trying to bind to one of the\n\
		// banned noData elements\n\
		if ( !elemData ) {\n\
			return;\n\
		}\n\
\n\
		var events = elemData.events,\n\
			eventHandle = elemData.handle;\n\
\n\
		if ( !events ) {\n\
			elemData.events = events = {};\n\
		}\n\
\n\
		if ( !eventHandle ) {\n\
			elemData.handle = eventHandle = function( e ) {\n\
				// Discard the second event of a jQuery.event.trigger() and\n\
				// when an event is called after a page has unloaded\n\
				return typeof jQuery !== \"undefined\" && (!e || jQuery.event.triggered !== e.type) ?\n\
					jQuery.event.handle.apply( eventHandle.elem, arguments ) :\n\
					undefined;\n\
			};\n\
		}\n\
\n\
		// Add elem as a property of the handle function\n\
		// This is to prevent a memory leak with non-native events in IE.\n\
		eventHandle.elem = elem;\n\
\n\
		// Handle multiple events separated by a space\n\
		// jQuery(...).bind(\"mouseover mouseout\", fn);\n\
		types = types.split(\" \");\n\
\n\
		var type, i = 0, namespaces;\n\
\n\
		while ( (type = types[ i++ ]) ) {\n\
			handleObj = handleObjIn ?\n\
				jQuery.extend({}, handleObjIn) :\n\
				{ handler: handler, data: data };\n\
\n\
			// Namespaced event handlers\n\
			if ( type.indexOf(\".\") > -1 ) {\n\
				namespaces = type.split(\".\");\n\
				type = namespaces.shift();\n\
				handleObj.namespace = namespaces.slice(0).sort().join(\".\");\n\
\n\
			} else {\n\
				namespaces = [];\n\
				handleObj.namespace = \"\";\n\
			}\n\
\n\
			handleObj.type = type;\n\
			if ( !handleObj.guid ) {\n\
				handleObj.guid = handler.guid;\n\
			}\n\
\n\
			// Get the current list of functions bound to this event\n\
			var handlers = events[ type ],\n\
				special = jQuery.event.special[ type ] || {};\n\
\n\
			// Init the event handler queue\n\
			if ( !handlers ) {\n\
				handlers = events[ type ] = [];\n\
\n\
				// Check for a special event handler\n\
				// Only use addEventListener/attachEvent if the special\n\
				// events handler returns false\n\
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\
					// Bind the global event handler to the element\n\
					if ( elem.addEventListener ) {\n\
						elem.addEventListener( type, eventHandle, false );\n\
\n\
					} else if ( elem.attachEvent ) {\n\
						elem.attachEvent( \"on\" + type, eventHandle );\n\
					}\n\
				}\n\
			}\n\
\n\
			if ( special.add ) {\n\
				special.add.call( elem, handleObj );\n\
\n\
				if ( !handleObj.handler.guid ) {\n\
					handleObj.handler.guid = handler.guid;\n\
				}\n\
			}\n\
\n\
			// Add the function to the element's handler list\n\
			handlers.push( handleObj );\n\
\n\
			// Keep track of which events have been used, for event optimization\n\
			jQuery.event.global[ type ] = true;\n\
		}\n\
\n\
		// Nullify elem to prevent memory leaks in IE\n\
		elem = null;\n\
	},\n\
\n\
	global: {},\n\
\n\
	// Detach an event or set of events from an element\n\
	remove: function( elem, types, handler, pos ) {\n\
		// don't do events on text and comment nodes\n\
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\
			return;\n\
		}\n\
\n\
		if ( handler === false ) {\n\
			handler = returnFalse;\n\
		}\n\
\n\
		var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,\n\
			elemData = jQuery.hasData( elem ) && jQuery._data( elem ),\n\
			events = elemData && elemData.events;\n\
\n\
		if ( !elemData || !events ) {\n\
			return;\n\
		}\n\
\n\
		// types is actually an event object here\n\
		if ( types && types.type ) {\n\
			handler = types.handler;\n\
			types = types.type;\n\
		}\n\
\n\
		// Unbind all events for the element\n\
		if ( !types || typeof types === \"string\" && types.charAt(0) === \".\" ) {\n\
			types = types || \"\";\n\
\n\
			for ( type in events ) {\n\
				jQuery.event.remove( elem, type + types );\n\
			}\n\
\n\
			return;\n\
		}\n\
\n\
		// Handle multiple events separated by a space\n\
		// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\
		types = types.split(\" \");\n\
\n\
		while ( (type = types[ i++ ]) ) {\n\
			origType = type;\n\
			handleObj = null;\n\
			all = type.indexOf(\".\") < 0;\n\
			namespaces = [];\n\
\n\
			if ( !all ) {\n\
				// Namespaced event handlers\n\
				namespaces = type.split(\".\");\n\
				type = namespaces.shift();\n\
\n\
				namespace = new RegExp(\"(^|\\\\.)\" +\n\
					jQuery.map( namespaces.slice(0).sort(), fcleanup ).join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\");\n\
			}\n\
\n\
			eventType = events[ type ];\n\
\n\
			if ( !eventType ) {\n\
				continue;\n\
			}\n\
\n\
			if ( !handler ) {\n\
				for ( j = 0; j < eventType.length; j++ ) {\n\
					handleObj = eventType[ j ];\n\
\n\
					if ( all || namespace.test( handleObj.namespace ) ) {\n\
						jQuery.event.remove( elem, origType, handleObj.handler, j );\n\
						eventType.splice( j--, 1 );\n\
					}\n\
				}\n\
\n\
				continue;\n\
			}\n\
\n\
			special = jQuery.event.special[ type ] || {};\n\
\n\
			for ( j = pos || 0; j < eventType.length; j++ ) {\n\
				handleObj = eventType[ j ];\n\
\n\
				if ( handler.guid === handleObj.guid ) {\n\
					// remove the given handler for the given type\n\
					if ( all || namespace.test( handleObj.namespace ) ) {\n\
						if ( pos == null ) {\n\
							eventType.splice( j--, 1 );\n\
						}\n\
\n\
						if ( special.remove ) {\n\
							special.remove.call( elem, handleObj );\n\
						}\n\
					}\n\
\n\
					if ( pos != null ) {\n\
						break;\n\
					}\n\
				}\n\
			}\n\
\n\
			// remove generic event handler if no more handlers exist\n\
			if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {\n\
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {\n\
					jQuery.removeEvent( elem, type, elemData.handle );\n\
				}\n\
\n\
				ret = null;\n\
				delete events[ type ];\n\
			}\n\
		}\n\
\n\
		// Remove the expando if it's no longer used\n\
		if ( jQuery.isEmptyObject( events ) ) {\n\
			var handle = elemData.handle;\n\
			if ( handle ) {\n\
				handle.elem = null;\n\
			}\n\
\n\
			delete elemData.events;\n\
			delete elemData.handle;\n\
\n\
			if ( jQuery.isEmptyObject( elemData ) ) {\n\
				jQuery.removeData( elem, undefined, true );\n\
			}\n\
		}\n\
	},\n\
	\n\
	// Events that are safe to short-circuit if no handlers are attached.\n\
	// Native DOM events should not be added, they may have inline handlers.\n\
	customEvent: {\n\
		\"getData\": true,\n\
		\"setData\": true,\n\
		\"changeData\": true\n\
	},\n\
\n\
	trigger: function( event, data, elem, onlyHandlers ) {\n\
		// Event object or event type\n\
		var type = event.type || event,\n\
			namespaces = [],\n\
			exclusive;\n\
\n\
		if ( type.indexOf(\"!\") >= 0 ) {\n\
			// Exclusive events trigger only for the exact event (no namespaces)\n\
			type = type.slice(0, -1);\n\
			exclusive = true;\n\
		}\n\
\n\
		if ( type.indexOf(\".\") >= 0 ) {\n\
			// Namespaced trigger; create a regexp to match event type in handle()\n\
			namespaces = type.split(\".\");\n\
			type = namespaces.shift();\n\
			namespaces.sort();\n\
		}\n\
\n\
		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {\n\
			// No jQuery handlers for this event type, and it can't have inline handlers\n\
			return;\n\
		}\n\
\n\
		// Caller can pass in an Event, Object, or just an event type string\n\
		event = typeof event === \"object\" ?\n\
			// jQuery.Event object\n\
			event[ jQuery.expando ] ? event :\n\
			// Object literal\n\
			new jQuery.Event( type, event ) :\n\
			// Just the event type (string)\n\
			new jQuery.Event( type );\n\
\n\
		event.type = type;\n\
		event.exclusive = exclusive;\n\
		event.namespace = namespaces.join(\".\");\n\
		event.namespace_re = new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\");\n\
		\n\
		// triggerHandler() and global events don't bubble or run the default action\n\
		if ( onlyHandlers || !elem ) {\n\
			event.preventDefault();\n\
			event.stopPropagation();\n\
		}\n\
\n\
		// Handle a global trigger\n\
		if ( !elem ) {\n\
			// TODO: Stop taunting the data cache; remove global events and always attach to document\n\
			jQuery.each( jQuery.cache, function() {\n\
				// internalKey variable is just used to make it easier to find\n\
				// and potentially change this stuff later; currently it just\n\
				// points to jQuery.expando\n\
				var internalKey = jQuery.expando,\n\
					internalCache = this[ internalKey ];\n\
				if ( internalCache && internalCache.events && internalCache.events[ type ] ) {\n\
					jQuery.event.trigger( event, data, internalCache.handle.elem );\n\
				}\n\
			});\n\
			return;\n\
		}\n\
\n\
		// Don't do events on text and comment nodes\n\
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\
			return;\n\
		}\n\
\n\
		// Clean up the event in case it is being reused\n\
		event.result = undefined;\n\
		event.target = elem;\n\
\n\
		// Clone any incoming data and prepend the event, creating the handler arg list\n\
		data = data != null ? jQuery.makeArray( data ) : [];\n\
		data.unshift( event );\n\
\n\
		var cur = elem,\n\
			// IE doesn't like method names with a colon (#3533, #8272)\n\
			ontype = type.indexOf(\":\") < 0 ? \"on\" + type : \"\";\n\
\n\
		// Fire event on the current element, then bubble up the DOM tree\n\
		do {\n\
			var handle = jQuery._data( cur, \"handle\" );\n\
\n\
			event.currentTarget = cur;\n\
			if ( handle ) {\n\
				handle.apply( cur, data );\n\
			}\n\
\n\
			// Trigger an inline bound script\n\
			if ( ontype && jQuery.acceptData( cur ) && cur[ ontype ] && cur[ ontype ].apply( cur, data ) === false ) {\n\
				event.result = false;\n\
				event.preventDefault();\n\
			}\n\
\n\
			// Bubble up to document, then to window\n\
			cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;\n\
		} while ( cur && !event.isPropagationStopped() );\n\
\n\
		// If nobody prevented the default action, do it now\n\
		if ( !event.isDefaultPrevented() ) {\n\
			var old,\n\
				special = jQuery.event.special[ type ] || {};\n\
\n\
			if ( (!special._default || special._default.call( elem.ownerDocument, event ) === false) &&\n\
				!(type === \"click\" && jQuery.nodeName( elem, \"a\" )) && jQuery.acceptData( elem ) ) {\n\
\n\
				// Call a native DOM method on the target with the same name name as the event.\n\
				// Can't use an .isFunction)() check here because IE6/7 fails that test.\n\
				// IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.\n\
				try {\n\
					if ( ontype && elem[ type ] ) {\n\
						// Don't re-trigger an onFOO event when we call its FOO() method\n\
						old = elem[ ontype ];\n\
\n\
						if ( old ) {\n\
							elem[ ontype ] = null;\n\
						}\n\
\n\
						jQuery.event.triggered = type;\n\
						elem[ type ]();\n\
					}\n\
				} catch ( ieError ) {}\n\
\n\
				if ( old ) {\n\
					elem[ ontype ] = old;\n\
				}\n\
\n\
				jQuery.event.triggered = undefined;\n\
			}\n\
		}\n\
		\n\
		return event.result;\n\
	},\n\
\n\
	handle: function( event ) {\n\
		event = jQuery.event.fix( event || window.event );\n\
		// Snapshot the handlers list since a called handler may add/remove events.\n\
		var handlers = ((jQuery._data( this, \"events\" ) || {})[ event.type ] || []).slice(0),\n\
			run_all = !event.exclusive && !event.namespace,\n\
			args = Array.prototype.slice.call( arguments, 0 );\n\
\n\
		// Use the fix-ed Event rather than the (read-only) native event\n\
		args[0] = event;\n\
		event.currentTarget = this;\n\
\n\
		for ( var j = 0, l = handlers.length; j < l; j++ ) {\n\
			var handleObj = handlers[ j ];\n\
\n\
			// Triggered event must 1) be non-exclusive and have no namespace, or\n\
			// 2) have namespace(s) a subset or equal to those in the bound event.\n\
			if ( run_all || event.namespace_re.test( handleObj.namespace ) ) {\n\
				// Pass in a reference to the handler function itself\n\
				// So that we can later remove it\n\
				event.handler = handleObj.handler;\n\
				event.data = handleObj.data;\n\
				event.handleObj = handleObj;\n\
\n\
				var ret = handleObj.handler.apply( this, args );\n\
\n\
				if ( ret !== undefined ) {\n\
					event.result = ret;\n\
					if ( ret === false ) {\n\
						event.preventDefault();\n\
						event.stopPropagation();\n\
					}\n\
				}\n\
\n\
				if ( event.isImmediatePropagationStopped() ) {\n\
					break;\n\
				}\n\
			}\n\
		}\n\
		return event.result;\n\
	},\n\
\n\
	props: \"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which\".split(\" \"),\n\
\n\
	fix: function( event ) {\n\
		if ( event[ jQuery.expando ] ) {\n\
			return event;\n\
		}\n\
\n\
		// store a copy of the original event object\n\
		// and \"clone\" to set read-only properties\n\
		var originalEvent = event;\n\
		event = jQuery.Event( originalEvent );\n\
\n\
		for ( var i = this.props.length, prop; i; ) {\n\
			prop = this.props[ --i ];\n\
			event[ prop ] = originalEvent[ prop ];\n\
		}\n\
\n\
		// Fix target property, if necessary\n\
		if ( !event.target ) {\n\
			// Fixes #1925 where srcElement might not be defined either\n\
			event.target = event.srcElement || document;\n\
		}\n\
\n\
		// check if target is a textnode (safari)\n\
		if ( event.target.nodeType === 3 ) {\n\
			event.target = event.target.parentNode;\n\
		}\n\
\n\
		// Add relatedTarget, if necessary\n\
		if ( !event.relatedTarget && event.fromElement ) {\n\
			event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n\
		}\n\
\n\
		// Calculate pageX/Y if missing and clientX/Y available\n\
		if ( event.pageX == null && event.clientX != null ) {\n\
			var eventDocument = event.target.ownerDocument || document,\n\
				doc = eventDocument.documentElement,\n\
				body = eventDocument.body;\n\
\n\
			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n\
			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);\n\
		}\n\
\n\
		// Add which for key events\n\
		if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {\n\
			event.which = event.charCode != null ? event.charCode : event.keyCode;\n\
		}\n\
\n\
		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)\n\
		if ( !event.metaKey && event.ctrlKey ) {\n\
			event.metaKey = event.ctrlKey;\n\
		}\n\
\n\
		// Add which for click: 1 === left; 2 === middle; 3 === right\n\
		// Note: button is not normalized, so don't use it\n\
		if ( !event.which && event.button !== undefined ) {\n\
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));\n\
		}\n\
\n\
		return event;\n\
	},\n\
\n\
	// Deprecated, use jQuery.guid instead\n\
	guid: 1E8,\n\
\n\
	// Deprecated, use jQuery.proxy instead\n\
	proxy: jQuery.proxy,\n\
\n\
	special: {\n\
		ready: {\n\
			// Make sure the ready event is setup\n\
			setup: jQuery.bindReady,\n\
			teardown: jQuery.noop\n\
		},\n\
\n\
		live: {\n\
			add: function( handleObj ) {\n\
				jQuery.event.add( this,\n\
					liveConvert( handleObj.origType, handleObj.selector ),\n\
					jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );\n\
			},\n\
\n\
			remove: function( handleObj ) {\n\
				jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );\n\
			}\n\
		},\n\
\n\
		beforeunload: {\n\
			setup: function( data, namespaces, eventHandle ) {\n\
				// We only want to do this special case on windows\n\
				if ( jQuery.isWindow( this ) ) {\n\
					this.onbeforeunload = eventHandle;\n\
				}\n\
			},\n\
\n\
			teardown: function( namespaces, eventHandle ) {\n\
				if ( this.onbeforeunload === eventHandle ) {\n\
					this.onbeforeunload = null;\n\
				}\n\
			}\n\
		}\n\
	}\n\
};\n\
\n\
jQuery.removeEvent = document.removeEventListener ?\n\
	function( elem, type, handle ) {\n\
		if ( elem.removeEventListener ) {\n\
			elem.removeEventListener( type, handle, false );\n\
		}\n\
	} :\n\
	function( elem, type, handle ) {\n\
		if ( elem.detachEvent ) {\n\
			elem.detachEvent( \"on\" + type, handle );\n\
		}\n\
	};\n\
\n\
jQuery.Event = function( src, props ) {\n\
	// Allow instantiation without the 'new' keyword\n\
	if ( !this.preventDefault ) {\n\
		return new jQuery.Event( src, props );\n\
	}\n\
\n\
	// Event object\n\
	if ( src && src.type ) {\n\
		this.originalEvent = src;\n\
		this.type = src.type;\n\
\n\
		// Events bubbling up the document may have been marked as prevented\n\
		// by a handler lower down the tree; reflect the correct value.\n\
		this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||\n\
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;\n\
\n\
	// Event type\n\
	} else {\n\
		this.type = src;\n\
	}\n\
\n\
	// Put explicitly provided properties onto the event object\n\
	if ( props ) {\n\
		jQuery.extend( this, props );\n\
	}\n\
\n\
	// timeStamp is buggy for some events on Firefox(#3843)\n\
	// So we won't rely on the native value\n\
	this.timeStamp = jQuery.now();\n\
\n\
	// Mark it as fixed\n\
	this[ jQuery.expando ] = true;\n\
};\n\
\n\
function returnFalse() {\n\
	return false;\n\
}\n\
function returnTrue() {\n\
	return true;\n\
}\n\
\n\
// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\
jQuery.Event.prototype = {\n\
	preventDefault: function() {\n\
		this.isDefaultPrevented = returnTrue;\n\
\n\
		var e = this.originalEvent;\n\
		if ( !e ) {\n\
			return;\n\
		}\n\
\n\
		// if preventDefault exists run it on the original event\n\
		if ( e.preventDefault ) {\n\
			e.preventDefault();\n\
\n\
		// otherwise set the returnValue property of the original event to false (IE)\n\
		} else {\n\
			e.returnValue = false;\n\
		}\n\
	},\n\
	stopPropagation: function() {\n\
		this.isPropagationStopped = returnTrue;\n\
\n\
		var e = this.originalEvent;\n\
		if ( !e ) {\n\
			return;\n\
		}\n\
		// if stopPropagation exists run it on the original event\n\
		if ( e.stopPropagation ) {\n\
			e.stopPropagation();\n\
		}\n\
		// otherwise set the cancelBubble property of the original event to true (IE)\n\
		e.cancelBubble = true;\n\
	},\n\
	stopImmediatePropagation: function() {\n\
		this.isImmediatePropagationStopped = returnTrue;\n\
		this.stopPropagation();\n\
	},\n\
	isDefaultPrevented: returnFalse,\n\
	isPropagationStopped: returnFalse,\n\
	isImmediatePropagationStopped: returnFalse\n\
};\n\
\n\
// Checks if an event happened on an element within another element\n\
// Used in jQuery.event.special.mouseenter and mouseleave handlers\n\
var withinElement = function( event ) {\n\
\n\
	// Check if mouse(over|out) are still within the same parent element\n\
	var related = event.relatedTarget,\n\
		inside = false,\n\
		eventType = event.type;\n\
\n\
	event.type = event.data;\n\
\n\
	if ( related !== this ) {\n\
\n\
		if ( related ) {\n\
			inside = jQuery.contains( this, related );\n\
		}\n\
\n\
		if ( !inside ) {\n\
\n\
			jQuery.event.handle.apply( this, arguments );\n\
\n\
			event.type = eventType;\n\
		}\n\
	}\n\
},\n\
\n\
// In case of event delegation, we only need to rename the event.type,\n\
// liveHandler will take care of the rest.\n\
delegate = function( event ) {\n\
	event.type = event.data;\n\
	jQuery.event.handle.apply( this, arguments );\n\
};\n\
\n\
// Create mouseenter and mouseleave events\n\
jQuery.each({\n\
	mouseenter: \"mouseover\",\n\
	mouseleave: \"mouseout\"\n\
}, function( orig, fix ) {\n\
	jQuery.event.special[ orig ] = {\n\
		setup: function( data ) {\n\
			jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );\n\
		},\n\
		teardown: function( data ) {\n\
			jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );\n\
		}\n\
	};\n\
});\n\
\n\
// submit delegation\n\
if ( !jQuery.support.submitBubbles ) {\n\
\n\
	jQuery.event.special.submit = {\n\
		setup: function( data, namespaces ) {\n\
			if ( !jQuery.nodeName( this, \"form\" ) ) {\n\
				jQuery.event.add(this, \"click.specialSubmit\", function( e ) {\n\
					// Avoid triggering error on non-existent type attribute in IE VML (#7071)\n\
					var elem = e.target,\n\
						type = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.type : \"\";\n\
\n\
					if ( (type === \"submit\" || type === \"image\") && jQuery( elem ).closest(\"form\").length ) {\n\
				